import {
  dist_default
} from "./chunk-4L4YAOOP.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-D34JIY7P.js";
import {
  MDCSwitchRenderFoundation
} from "./chunk-EUDSUHOX.js";
import "./chunk-LVKEPJPU.js";
import "./chunk-WSTZOV6I.js";
import "./chunk-G23XUBRR.js";
import "./chunk-46WCSRWY.js";
import "./chunk-2AIYWHJH.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  claim_space,
  claim_svg_element,
  compute_rest_props,
  detach_dev,
  dispatch_dev,
  element,
  exclude_internal_props,
  getContext,
  get_current_component,
  get_spread_update,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  space,
  svg_element,
  validate_slots
} from "./chunk-BJ76AV5Z.js";
import "./chunk-LNQ46MIJ.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@smui/switch/dist/Switch.svelte
var file = "node_modules/@smui/switch/dist/Switch.svelte";
function create_if_block_1(ctx) {
  let div;
  let svg0;
  let path0;
  let t;
  let svg1;
  let path1;
  let div_class_value;
  let useActions_action;
  let mounted;
  let dispose;
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[8]]: true,
        "mdc-switch__icons": true
      })
    },
    prefixFilter(ctx[19], "icons$")
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      svg0 = svg_element("svg");
      path0 = svg_element("path");
      t = space();
      svg1 = svg_element("svg");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      svg0 = claim_svg_element(div_nodes, "svg", { class: true, viewBox: true });
      var svg0_nodes = children(svg0);
      path0 = claim_svg_element(svg0_nodes, "path", { d: true });
      children(path0).forEach(detach_dev);
      svg0_nodes.forEach(detach_dev);
      t = claim_space(div_nodes);
      svg1 = claim_svg_element(div_nodes, "svg", { class: true, viewBox: true });
      var svg1_nodes = children(svg1);
      path1 = claim_svg_element(svg1_nodes, "path", { d: true });
      children(path1).forEach(detach_dev);
      svg1_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M19.69,5.23L8.96,15.96l-4.23-4.23L2.96,13.5l6,6L21.46,7L19.69,5.23z");
      add_location(path0, file, 51, 12, 1407);
      attr_dev(svg0, "class", "mdc-switch__icon mdc-switch__icon--on");
      attr_dev(svg0, "viewBox", "0 0 24 24");
      add_location(svg0, file, 47, 10, 1288);
      attr_dev(path1, "d", "M20 13H4v-2h16v2z");
      add_location(path1, file, 59, 12, 1661);
      attr_dev(svg1, "class", "mdc-switch__icon mdc-switch__icon--off");
      attr_dev(svg1, "viewBox", "0 0 24 24");
      add_location(svg1, file, 55, 10, 1541);
      set_attributes(div, div_data);
      add_location(div, file, 39, 8, 1061);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, svg0);
      append_hydration_dev(svg0, path0);
      append_hydration_dev(div, t);
      append_hydration_dev(div, svg1);
      append_hydration_dev(svg1, path1);
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(null, div, ctx[7]));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty[0] & 256 && div_class_value !== (div_class_value = classMap({
          [ctx2[8]]: true,
          "mdc-switch__icons": true
        })) && { class: div_class_value },
        dirty[0] & 524288 && prefixFilter(ctx2[19], "icons$")
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 128)
        useActions_action.update.call(null, ctx2[7]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(39:6) {#if icons}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div1;
  let div0;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-switch__focus-ring");
      add_location(div0, file, 67, 6, 1829);
      attr_dev(div1, "class", "mdc-switch__focus-ring-wrapper");
      add_location(div1, file, 66, 4, 1778);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(66:2) {#if focusRing}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let button;
  let div0;
  let t0;
  let div5;
  let div4;
  let div2;
  let div1;
  let t1;
  let div3;
  let t2;
  let t3;
  let button_class_value;
  let button_aria_checked_value;
  let useActions_action;
  let forwardEvents_action;
  let Ripple_action;
  let mounted;
  let dispose;
  let if_block0 = ctx[6] && create_if_block_1(ctx);
  let if_block1 = ctx[4] && create_if_block(ctx);
  let button_levels = [
    {
      class: button_class_value = classMap({
        [ctx[3]]: true,
        "mdc-switch": true,
        "mdc-switch--unselected": !ctx[10],
        "mdc-switch--selected": ctx[10],
        "mdc-switch--processing": ctx[1],
        "smui-switch--color-secondary": ctx[5] === "secondary",
        ...ctx[12]
      })
    },
    { type: "button" },
    { role: "switch" },
    {
      "aria-checked": button_aria_checked_value = ctx[10] ? "true" : "false"
    },
    { disabled: ctx[0] },
    ctx[16],
    exclude(ctx[19], ["icons$"])
  ];
  let button_data = {};
  for (let i = 0; i < button_levels.length; i += 1) {
    button_data = assign(button_data, button_levels[i]);
  }
  const block = {
    c: function create() {
      button = element("button");
      div0 = element("div");
      t0 = space();
      div5 = element("div");
      div4 = element("div");
      div2 = element("div");
      div1 = element("div");
      t1 = space();
      div3 = element("div");
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true,
        type: true,
        role: true,
        "aria-checked": true
      });
      var button_nodes = children(button);
      div0 = claim_element(button_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(button_nodes);
      div5 = claim_element(button_nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div2 = claim_element(div4_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t1 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      children(div3).forEach(detach_dev);
      t2 = claim_space(div4_nodes);
      if (if_block0)
        if_block0.l(div4_nodes);
      div4_nodes.forEach(detach_dev);
      div5_nodes.forEach(detach_dev);
      t3 = claim_space(button_nodes);
      if (if_block1)
        if_block1.l(button_nodes);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-switch__track");
      add_location(div0, file, 31, 2, 758);
      attr_dev(div1, "class", "mdc-elevation-overlay");
      add_location(div1, file, 35, 8, 917);
      attr_dev(div2, "class", "mdc-switch__shadow");
      add_location(div2, file, 34, 6, 876);
      attr_dev(div3, "class", "mdc-switch__ripple");
      add_location(div3, file, 37, 6, 974);
      attr_dev(div4, "class", "mdc-switch__handle");
      add_location(div4, file, 33, 4, 837);
      attr_dev(div5, "class", "mdc-switch__handle-track");
      add_location(div5, file, 32, 2, 794);
      set_attributes(button, button_data);
      add_location(button, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, div0);
      append_hydration_dev(button, t0);
      append_hydration_dev(button, div5);
      append_hydration_dev(div5, div4);
      append_hydration_dev(div4, div2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div4, t1);
      append_hydration_dev(div4, div3);
      ctx[28](div3);
      append_hydration_dev(div4, t2);
      if (if_block0)
        if_block0.m(div4, null);
      append_hydration_dev(button, t3);
      if (if_block1)
        if_block1.m(button, null);
      if (button.autofocus)
        button.focus();
      ctx[29](button);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, button, ctx[2])),
          action_destroyer(forwardEvents_action = ctx[15].call(null, button)),
          action_destroyer(Ripple_action = dist_default.call(null, button, {
            unbounded: true,
            color: ctx[5],
            active: ctx[14],
            rippleElement: ctx[13],
            disabled: ctx[0],
            addClass: ctx[17],
            removeClass: ctx[18]
          })),
          listen_dev(button, "click", ctx[30], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (ctx2[6]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          if_block0.m(div4, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[4]) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          if_block1.m(button, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      set_attributes(button, button_data = get_spread_update(button_levels, [
        dirty[0] & 5162 && button_class_value !== (button_class_value = classMap({
          [ctx2[3]]: true,
          "mdc-switch": true,
          "mdc-switch--unselected": !ctx2[10],
          "mdc-switch--selected": ctx2[10],
          "mdc-switch--processing": ctx2[1],
          "smui-switch--color-secondary": ctx2[5] === "secondary",
          ...ctx2[12]
        })) && { class: button_class_value },
        { type: "button" },
        { role: "switch" },
        dirty[0] & 1024 && button_aria_checked_value !== (button_aria_checked_value = ctx2[10] ? "true" : "false") && {
          "aria-checked": button_aria_checked_value
        },
        dirty[0] & 1 && { disabled: ctx2[0] },
        ctx2[16],
        dirty[0] & 524288 && exclude(ctx2[19], ["icons$"])
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 4)
        useActions_action.update.call(null, ctx2[2]);
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 24609)
        Ripple_action.update.call(null, {
          unbounded: true,
          color: ctx2[5],
          active: ctx2[14],
          rippleElement: ctx2[13],
          disabled: ctx2[0],
          addClass: ctx2[17],
          removeClass: ctx2[18]
        });
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      ctx[28](null);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[29](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "disabled",
    "focusRing",
    "color",
    "group",
    "checked",
    "value",
    "processing",
    "icons",
    "icons$use",
    "icons$class",
    "getId",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switch", slots, []);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { disabled = false } = $$props;
  let { focusRing = false } = $$props;
  let { color = "primary" } = $$props;
  let { group = uninitializedValue } = $$props;
  let { checked = uninitializedValue } = $$props;
  let { value = null } = $$props;
  let { processing = false } = $$props;
  let { icons = true } = $$props;
  let { icons$use = [] } = $$props;
  let { icons$class = "" } = $$props;
  let element2;
  let instance;
  let internalClasses = {};
  let rippleElement;
  let rippleActive = false;
  let inputProps = (_a = getContext("SMUI:generic:input:props")) !== null && _a !== void 0 ? _a : {};
  let selected = isUninitializedValue(group) ? isUninitializedValue(checked) ? false : checked : group.indexOf(value) !== -1;
  let state = {
    get disabled() {
      return disabled;
    },
    set disabled(value2) {
      $$invalidate(0, disabled = value2);
    },
    get processing() {
      return processing;
    },
    set processing(value2) {
      $$invalidate(1, processing = value2);
    },
    get selected() {
      return selected;
    },
    set selected(value2) {
      $$invalidate(10, selected = value2);
    }
  };
  let previousChecked = checked;
  let previousGroup = isUninitializedValue(group) ? [] : [...group];
  let previousSelected = selected;
  onMount(() => {
    $$invalidate(11, instance = new MDCSwitchRenderFoundation({
      addClass,
      hasClass,
      isDisabled: () => disabled,
      removeClass,
      setAriaChecked: () => {
      },
      setDisabled: (value2) => {
        $$invalidate(0, disabled = value2);
      },
      state
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      get checked() {
        return selected;
      },
      set checked(checked2) {
        if (selected !== checked2) {
          state.selected = checked2;
          if (element2) {
            dispatch(element2, "SMUISwitch:change", { selected: checked2, value });
          }
        }
      },
      activateRipple() {
        if (!disabled) {
          $$invalidate(14, rippleActive = true);
        }
      },
      deactivateRipple() {
        $$invalidate(14, rippleActive = false);
      }
    };
    dispatch(element2, "SMUIGenericInput:mount", accessor);
    instance.init();
    instance.initFromDOM();
    return () => {
      dispatch(element2, "SMUIGenericInput:unmount", accessor);
      instance.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = false, internalClasses);
    }
  }
  function getId() {
    return inputProps && inputProps.id;
  }
  function getElement() {
    return element2;
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      rippleElement = $$value;
      $$invalidate(13, rippleElement);
    });
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(9, element2);
    });
  }
  const click_handler = () => instance && instance.handleClick();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("disabled" in $$new_props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("focusRing" in $$new_props)
      $$invalidate(4, focusRing = $$new_props.focusRing);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("group" in $$new_props)
      $$invalidate(20, group = $$new_props.group);
    if ("checked" in $$new_props)
      $$invalidate(21, checked = $$new_props.checked);
    if ("value" in $$new_props)
      $$invalidate(22, value = $$new_props.value);
    if ("processing" in $$new_props)
      $$invalidate(1, processing = $$new_props.processing);
    if ("icons" in $$new_props)
      $$invalidate(6, icons = $$new_props.icons);
    if ("icons$use" in $$new_props)
      $$invalidate(7, icons$use = $$new_props.icons$use);
    if ("icons$class" in $$new_props)
      $$invalidate(8, icons$class = $$new_props.icons$class);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCSwitchRenderFoundation,
    onMount,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    Ripple: dist_default,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    disabled,
    focusRing,
    color,
    group,
    checked,
    value,
    processing,
    icons,
    icons$use,
    icons$class,
    element: element2,
    instance,
    internalClasses,
    rippleElement,
    rippleActive,
    inputProps,
    selected,
    state,
    previousChecked,
    previousGroup,
    previousSelected,
    hasClass,
    addClass,
    removeClass,
    getId,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("disabled" in $$props)
      $$invalidate(0, disabled = $$new_props.disabled);
    if ("focusRing" in $$props)
      $$invalidate(4, focusRing = $$new_props.focusRing);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("group" in $$props)
      $$invalidate(20, group = $$new_props.group);
    if ("checked" in $$props)
      $$invalidate(21, checked = $$new_props.checked);
    if ("value" in $$props)
      $$invalidate(22, value = $$new_props.value);
    if ("processing" in $$props)
      $$invalidate(1, processing = $$new_props.processing);
    if ("icons" in $$props)
      $$invalidate(6, icons = $$new_props.icons);
    if ("icons$use" in $$props)
      $$invalidate(7, icons$use = $$new_props.icons$use);
    if ("icons$class" in $$props)
      $$invalidate(8, icons$class = $$new_props.icons$class);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(11, instance = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(12, internalClasses = $$new_props.internalClasses);
    if ("rippleElement" in $$props)
      $$invalidate(13, rippleElement = $$new_props.rippleElement);
    if ("rippleActive" in $$props)
      $$invalidate(14, rippleActive = $$new_props.rippleActive);
    if ("inputProps" in $$props)
      $$invalidate(16, inputProps = $$new_props.inputProps);
    if ("selected" in $$props)
      $$invalidate(10, selected = $$new_props.selected);
    if ("state" in $$props)
      state = $$new_props.state;
    if ("previousChecked" in $$props)
      $$invalidate(25, previousChecked = $$new_props.previousChecked);
    if ("previousGroup" in $$props)
      $$invalidate(26, previousGroup = $$new_props.previousGroup);
    if ("previousSelected" in $$props)
      $$invalidate(27, previousSelected = $$new_props.previousSelected);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 242222592) {
      $: {
        let notifyChange = false;
        if (!isUninitializedValue(group)) {
          if (previousSelected !== selected) {
            const idx = group.indexOf(value);
            if (selected && idx === -1) {
              group.push(value);
              $$invalidate(20, group), $$invalidate(27, previousSelected), $$invalidate(10, selected), $$invalidate(22, value), $$invalidate(26, previousGroup), $$invalidate(21, checked), $$invalidate(25, previousChecked), $$invalidate(9, element2);
            } else if (!selected && idx !== -1) {
              group.splice(idx, 1);
              $$invalidate(20, group), $$invalidate(27, previousSelected), $$invalidate(10, selected), $$invalidate(22, value), $$invalidate(26, previousGroup), $$invalidate(21, checked), $$invalidate(25, previousChecked), $$invalidate(9, element2);
            }
            notifyChange = true;
          } else {
            const idxPrev = previousGroup.indexOf(value);
            const idx = group.indexOf(value);
            if (idxPrev > -1 && idx === -1) {
              state.selected = false;
            } else if (idx > -1 && idxPrev === -1) {
              state.selected = true;
            }
          }
        }
        if (isUninitializedValue(checked)) {
          if (previousSelected !== selected) {
            notifyChange = true;
          }
        } else if (checked !== selected) {
          if (checked === previousChecked) {
            $$invalidate(21, checked = selected);
            notifyChange = true;
          } else {
            state.selected = checked;
          }
        }
        $$invalidate(25, previousChecked = checked);
        $$invalidate(26, previousGroup = isUninitializedValue(group) ? [] : [...group]);
        $$invalidate(27, previousSelected = selected);
        if (notifyChange && element2) {
          dispatch(element2, "SMUISwitch:change", { selected, value });
        }
      }
    }
  };
  return [
    disabled,
    processing,
    use,
    className,
    focusRing,
    color,
    icons,
    icons$use,
    icons$class,
    element2,
    selected,
    instance,
    internalClasses,
    rippleElement,
    rippleActive,
    forwardEvents,
    inputProps,
    addClass,
    removeClass,
    $$restProps,
    group,
    checked,
    value,
    getId,
    getElement,
    previousChecked,
    previousGroup,
    previousSelected,
    div3_binding,
    button_binding,
    click_handler
  ];
}
var Switch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 2,
        class: 3,
        disabled: 0,
        focusRing: 4,
        color: 5,
        group: 20,
        checked: 21,
        value: 22,
        processing: 1,
        icons: 6,
        icons$use: 7,
        icons$class: 8,
        getId: 23,
        getElement: 24
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switch",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusRing() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusRing(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get group() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set group(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get processing() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set processing(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icons() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icons$use() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons$use(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get icons$class() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set icons$class(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getId() {
    return this.$$.ctx[23];
  }
  set getId(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[24];
  }
  set getElement(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switch_default = Switch;

// node_modules/@smui/switch/dist/index.js
var dist_default2 = Switch_default;
export {
  dist_default2 as default
};
//# sourceMappingURL=@smui_switch.js.map
