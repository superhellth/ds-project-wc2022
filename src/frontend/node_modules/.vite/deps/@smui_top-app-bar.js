import {
  classAdderBuilder
} from "./chunk-X2VOPA5X.js";
import {
  SmuiElement_default
} from "./chunk-JAEGY7F6.js";
import {
  classMap,
  dispatch,
  forwardEventsBuilder,
  useActions
} from "./chunk-D34JIY7P.js";
import {
  MDCFixedTopAppBarFoundation,
  MDCShortTopAppBarFoundation,
  MDCTopAppBarBaseFoundation,
  MDCTopAppBarFoundation
} from "./chunk-IFRCFMMD.js";
import "./chunk-G23XUBRR.js";
import "./chunk-46WCSRWY.js";
import "./chunk-2AIYWHJH.js";
import {
  readable
} from "./chunk-QKQJIKFJ.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  assign,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  subscribe,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-BJ76AV5Z.js";
import "./chunk-LNQ46MIJ.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@smui/top-app-bar/dist/TopAppBar.svelte
var { window: window_1 } = globals;
var file = "node_modules\\@smui\\top-app-bar\\dist\\TopAppBar.svelte";
function create_fragment(ctx) {
  let header;
  let header_class_value;
  let header_style_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[22].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
  let header_levels = [
    {
      class: header_class_value = classMap({
        [ctx[2]]: true,
        "mdc-top-app-bar": true,
        "mdc-top-app-bar--short": ctx[4] === "short",
        "mdc-top-app-bar--short-collapsed": ctx[0],
        "mdc-top-app-bar--fixed": ctx[4] === "fixed",
        "smui-top-app-bar--static": ctx[4] === "static",
        "smui-top-app-bar--color-secondary": ctx[5] === "secondary",
        "mdc-top-app-bar--prominent": ctx[6],
        "mdc-top-app-bar--dense": ctx[7],
        ...ctx[11]
      })
    },
    {
      style: header_style_value = Object.entries(ctx[12]).map(func).concat([ctx[3]]).join(" ")
    },
    ctx[15]
  ];
  let header_data = {};
  for (let i = 0; i < header_levels.length; i += 1) {
    header_data = assign(header_data, header_levels[i]);
  }
  const block = {
    c: function create() {
      header = element("header");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", { class: true, style: true });
      var header_nodes = children(header);
      if (default_slot)
        default_slot.l(header_nodes);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(header, header_data);
      add_location(header, file, 9, 0, 208);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      if (default_slot) {
        default_slot.m(header, null);
      }
      ctx[25](header);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(window_1, "resize", ctx[23], false, false, false),
          listen_dev(window_1, "scroll", ctx[24], false, false, false),
          action_destroyer(useActions_action = useActions.call(null, header, ctx[1])),
          action_destroyer(forwardEvents_action = ctx[13].call(null, header)),
          listen_dev(header, "SMUITopAppBarIconButton:nav", ctx[26], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & 2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null),
            null
          );
        }
      }
      set_attributes(header, header_data = get_spread_update(header_levels, [
        (!current || dirty[0] & 2293 && header_class_value !== (header_class_value = classMap({
          [ctx2[2]]: true,
          "mdc-top-app-bar": true,
          "mdc-top-app-bar--short": ctx2[4] === "short",
          "mdc-top-app-bar--short-collapsed": ctx2[0],
          "mdc-top-app-bar--fixed": ctx2[4] === "fixed",
          "smui-top-app-bar--static": ctx2[4] === "static",
          "smui-top-app-bar--color-secondary": ctx2[5] === "secondary",
          "mdc-top-app-bar--prominent": ctx2[6],
          "mdc-top-app-bar--dense": ctx2[7],
          ...ctx2[11]
        }))) && { class: header_class_value },
        (!current || dirty[0] & 4104 && header_style_value !== (header_style_value = Object.entries(ctx2[12]).map(func).concat([ctx2[3]]).join(" "))) && { style: header_style_value },
        dirty[0] & 32768 && ctx2[15]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 2)
        useActions_action.update.call(null, ctx2[1]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(header);
      if (default_slot)
        default_slot.d(detaching);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "variant",
    "color",
    "collapsed",
    "prominent",
    "dense",
    "scrollTarget",
    "getPropStore",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TopAppBar", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { variant = "standard" } = $$props;
  let { color = "primary" } = $$props;
  let { collapsed = uninitializedValue } = $$props;
  const alwaysCollapsed = !isUninitializedValue(collapsed) && !!collapsed;
  if (isUninitializedValue(collapsed)) {
    collapsed = false;
  }
  let { prominent = false } = $$props;
  let { dense = false } = $$props;
  let { scrollTarget = void 0 } = $$props;
  let element2;
  let instance3;
  let internalClasses = {};
  let internalStyles = {};
  let propStoreSet;
  let propStore = readable({ variant, prominent, dense }, (set) => {
    $$invalidate(18, propStoreSet = set);
  });
  let oldScrollTarget = void 0;
  let oldVariant = variant;
  onMount(() => {
    $$invalidate(9, instance3 = getInstance());
    instance3.init();
    return () => {
      instance3.destroy();
    };
  });
  function getInstance() {
    const Foundation = {
      static: MDCTopAppBarBaseFoundation,
      short: MDCShortTopAppBarFoundation,
      fixed: MDCFixedTopAppBarFoundation,
      standard: MDCTopAppBarFoundation
    }[variant] || MDCTopAppBarFoundation;
    return new Foundation({
      hasClass,
      addClass,
      removeClass,
      setStyle: addStyle,
      getTopAppBarHeight: () => element2.clientHeight,
      notifyNavigationIconClicked: () => dispatch(element2, "SMUITopAppBar:nav", void 0, void 0, true),
      getViewportScrollY: () => scrollTarget == null ? window.pageYOffset : scrollTarget.scrollTop,
      getTotalActionItems: () => element2.querySelectorAll(".mdc-top-app-bar__action-item").length
    });
  }
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(12, internalStyles), $$invalidate(20, oldVariant), $$invalidate(4, variant), $$invalidate(9, instance3);
      } else {
        $$invalidate(12, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function handleTargetScroll() {
    if (instance3) {
      instance3.handleTargetScroll();
      if (variant === "short") {
        $$invalidate(0, collapsed = "isCollapsed" in instance3 && instance3.isCollapsed);
      }
    }
  }
  function getPropStore() {
    return propStore;
  }
  function getElement() {
    return element2;
  }
  const resize_handler = () => variant !== "short" && variant !== "fixed" && instance3 && instance3.handleWindowResize();
  const scroll_handler = () => scrollTarget == null && handleTargetScroll();
  function header_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(10, element2);
    });
  }
  const SMUITopAppBarIconButton_nav_handler = () => instance3 && instance3.handleNavigationClick();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(15, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(3, style = $$new_props.style);
    if ("variant" in $$new_props)
      $$invalidate(4, variant = $$new_props.variant);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("collapsed" in $$new_props)
      $$invalidate(0, collapsed = $$new_props.collapsed);
    if ("prominent" in $$new_props)
      $$invalidate(6, prominent = $$new_props.prominent);
    if ("dense" in $$new_props)
      $$invalidate(7, dense = $$new_props.dense);
    if ("scrollTarget" in $$new_props)
      $$invalidate(8, scrollTarget = $$new_props.scrollTarget);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCTopAppBarBaseFoundation,
    MDCTopAppBarFoundation,
    MDCFixedTopAppBarFoundation,
    MDCShortTopAppBarFoundation,
    onMount,
    get_current_component,
    readable,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    style,
    variant,
    color,
    collapsed,
    alwaysCollapsed,
    prominent,
    dense,
    scrollTarget,
    element: element2,
    instance: instance3,
    internalClasses,
    internalStyles,
    propStoreSet,
    propStore,
    oldScrollTarget,
    oldVariant,
    getInstance,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    handleTargetScroll,
    getPropStore,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(3, style = $$new_props.style);
    if ("variant" in $$props)
      $$invalidate(4, variant = $$new_props.variant);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("collapsed" in $$props)
      $$invalidate(0, collapsed = $$new_props.collapsed);
    if ("prominent" in $$props)
      $$invalidate(6, prominent = $$new_props.prominent);
    if ("dense" in $$props)
      $$invalidate(7, dense = $$new_props.dense);
    if ("scrollTarget" in $$props)
      $$invalidate(8, scrollTarget = $$new_props.scrollTarget);
    if ("element" in $$props)
      $$invalidate(10, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(9, instance3 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(11, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(12, internalStyles = $$new_props.internalStyles);
    if ("propStoreSet" in $$props)
      $$invalidate(18, propStoreSet = $$new_props.propStoreSet);
    if ("propStore" in $$props)
      propStore = $$new_props.propStore;
    if ("oldScrollTarget" in $$props)
      $$invalidate(19, oldScrollTarget = $$new_props.oldScrollTarget);
    if ("oldVariant" in $$props)
      $$invalidate(20, oldVariant = $$new_props.oldVariant);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 262352) {
      $:
        if (propStoreSet) {
          propStoreSet({ variant, prominent, dense });
        }
    }
    if ($$self.$$.dirty[0] & 1049104) {
      $:
        if (oldVariant !== variant && instance3) {
          $$invalidate(20, oldVariant = variant);
          instance3.destroy();
          $$invalidate(11, internalClasses = {});
          $$invalidate(12, internalStyles = {});
          $$invalidate(9, instance3 = getInstance());
          instance3.init();
        }
    }
    if ($$self.$$.dirty[0] & 528) {
      $:
        if (instance3 && variant === "short" && "setAlwaysCollapsed" in instance3) {
          instance3.setAlwaysCollapsed(alwaysCollapsed);
        }
    }
    if ($$self.$$.dirty[0] & 524544) {
      $:
        if (oldScrollTarget !== scrollTarget) {
          if (oldScrollTarget) {
            oldScrollTarget.removeEventListener("scroll", handleTargetScroll);
          }
          if (scrollTarget) {
            scrollTarget.addEventListener("scroll", handleTargetScroll);
          }
          $$invalidate(19, oldScrollTarget = scrollTarget);
        }
    }
  };
  return [
    collapsed,
    use,
    className,
    style,
    variant,
    color,
    prominent,
    dense,
    scrollTarget,
    instance3,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    handleTargetScroll,
    $$restProps,
    getPropStore,
    getElement,
    propStoreSet,
    oldScrollTarget,
    oldVariant,
    $$scope,
    slots,
    resize_handler,
    scroll_handler,
    header_binding,
    SMUITopAppBarIconButton_nav_handler
  ];
}
var TopAppBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 1,
        class: 2,
        style: 3,
        variant: 4,
        color: 5,
        collapsed: 0,
        prominent: 6,
        dense: 7,
        scrollTarget: 8,
        getPropStore: 16,
        getElement: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TopAppBar",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get collapsed() {
    throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set collapsed(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get prominent() {
    throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set prominent(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dense() {
    throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dense(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollTarget() {
    throw new Error("<TopAppBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollTarget(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getPropStore() {
    return this.$$.ctx[16];
  }
  set getPropStore(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[17];
  }
  set getElement(value) {
    throw new Error("<TopAppBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TopAppBar_default = TopAppBar;

// node_modules/@smui/top-app-bar/dist/Row.js
var Row_default = classAdderBuilder({
  class: "mdc-top-app-bar__row",
  tag: "div"
});

// node_modules/@smui/top-app-bar/dist/Section.svelte
var file2 = "node_modules\\@smui\\top-app-bar\\dist\\Section.svelte";
function create_fragment2(ctx) {
  let section;
  let section_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  let section_levels = [
    {
      class: section_class_value = classMap({
        [ctx[1]]: true,
        "mdc-top-app-bar__section": true,
        "mdc-top-app-bar__section--align-start": ctx[2] === "start",
        "mdc-top-app-bar__section--align-end": ctx[2] === "end"
      })
    },
    ctx[3] ? { role: "toolbar" } : {},
    ctx[6]
  ];
  let section_data = {};
  for (let i = 0; i < section_levels.length; i += 1) {
    section_data = assign(section_data, section_levels[i]);
  }
  const block = {
    c: function create() {
      section = element("section");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      section = claim_element(nodes, "SECTION", { class: true });
      var section_nodes = children(section);
      if (default_slot)
        default_slot.l(section_nodes);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(section, section_data);
      add_location(section, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, section, anchor);
      if (default_slot) {
        default_slot.m(section, null);
      }
      ctx[10](section);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, section, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[5].call(null, section))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[8],
            !current ? get_all_dirty_from_scope(ctx2[8]) : get_slot_changes(default_slot_template, ctx2[8], dirty, null),
            null
          );
        }
      }
      set_attributes(section, section_data = get_spread_update(section_levels, [
        (!current || dirty & 6 && section_class_value !== (section_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-top-app-bar__section": true,
          "mdc-top-app-bar__section--align-start": ctx2[2] === "start",
          "mdc-top-app-bar__section--align-end": ctx2[2] === "end"
        }))) && { class: section_class_value },
        dirty & 8 && (ctx2[3] ? { role: "toolbar" } : {}),
        dirty & 64 && ctx2[6]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(section);
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "align", "toolbar", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Section", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { align = "start" } = $$props;
  let { toolbar = false } = $$props;
  let element2;
  setContext("SMUI:icon-button:context", toolbar ? "top-app-bar:action" : "top-app-bar:navigation");
  setContext("SMUI:button:context", toolbar ? "top-app-bar:action" : "top-app-bar:navigation");
  function getElement() {
    return element2;
  }
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("align" in $$new_props)
      $$invalidate(2, align = $$new_props.align);
    if ("toolbar" in $$new_props)
      $$invalidate(3, toolbar = $$new_props.toolbar);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    align,
    toolbar,
    element: element2,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("align" in $$props)
      $$invalidate(2, align = $$new_props.align);
    if ("toolbar" in $$props)
      $$invalidate(3, toolbar = $$new_props.toolbar);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    align,
    toolbar,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    section_binding
  ];
}
var Section = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment2, safe_not_equal, {
      use: 0,
      class: 1,
      align: 2,
      toolbar: 3,
      getElement: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Section",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get toolbar() {
    throw new Error("<Section>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set toolbar(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[7];
  }
  set getElement(value) {
    throw new Error("<Section>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Section_default = Section;

// node_modules/@smui/top-app-bar/dist/Title.js
var Title_default = classAdderBuilder({
  class: "mdc-top-app-bar__title",
  tag: "span"
});

// node_modules/@smui/top-app-bar/dist/FixedAdjust.js
function FixedAdjust(node) {
  node.classList.add("mdc-top-app-bar--fixed-adjust");
  return {
    destroy() {
      node.classList.remove("mdc-top-app-bar--fixed-adjust");
    }
  };
}

// node_modules/@smui/top-app-bar/dist/ProminentFixedAdjust.js
function ProminentFixedAdjust(node) {
  node.classList.add("mdc-top-app-bar--prominent-fixed-adjust");
  return {
    destroy() {
      node.classList.remove("mdc-top-app-bar--prominent-fixed-adjust");
    }
  };
}

// node_modules/@smui/top-app-bar/dist/DenseFixedAdjust.js
function DenseFixedAdjust(node) {
  node.classList.add("mdc-top-app-bar--dense-fixed-adjust");
  return {
    destroy() {
      node.classList.remove("mdc-top-app-bar--dense-fixed-adjust");
    }
  };
}

// node_modules/@smui/top-app-bar/dist/DenseProminentFixedAdjust.js
function DenseProminentFixedAdjust(node) {
  node.classList.add("mdc-top-app-bar--dense-prominent-fixed-adjust");
  return {
    destroy() {
      node.classList.remove("mdc-top-app-bar--dense-prominent-fixed-adjust");
    }
  };
}

// node_modules/@smui/top-app-bar/dist/ShortFixedAdjust.js
function ShortFixedAdjust(node) {
  node.classList.add("mdc-top-app-bar--short-fixed-adjust");
  return {
    destroy() {
      node.classList.remove("mdc-top-app-bar--short-fixed-adjust");
    }
  };
}

// node_modules/@smui/top-app-bar/dist/AutoAdjust.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[12].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[14], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[14],
            !current ? get_all_dirty_from_scope(ctx2[14]) : get_slot_changes(default_slot_template, ctx2[14], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   {tag}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     [adjustClass]: true,   })}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: ctx[3] },
    {
      use: [ctx[7], ...ctx[0]]
    },
    {
      class: classMap({
        [ctx[1]]: true,
        [ctx[6]]: true
      })
    },
    ctx[8]
  ];
  var switch_value = ctx[2];
  function switch_props(ctx2) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[13](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const switch_instance_changes = dirty & 459 ? get_spread_update(switch_instance_spread_levels, [
        dirty & 8 && { tag: ctx2[3] },
        dirty & 129 && {
          use: [ctx2[7], ...ctx2[0]]
        },
        dirty & 66 && {
          class: classMap({
            [ctx2[1]]: true,
            [ctx2[6]]: true
          })
        },
        dirty & 256 && get_spread_object(ctx2[8])
      ]) : {};
      if (dirty & 16384) {
        switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (switch_value !== (switch_value = ctx2[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          ctx2[13](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[13](null);
      if (detaching)
        detach_dev(switch_instance_anchor);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let propStore;
  let adjustClass;
  const omit_props_names = ["use", "class", "topAppBar", "component", "tag", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $propStore, $$unsubscribe_propStore = noop, $$subscribe_propStore = () => ($$unsubscribe_propStore(), $$unsubscribe_propStore = subscribe(propStore, ($$value) => $$invalidate(11, $propStore = $$value)), propStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_propStore());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("AutoAdjust", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { topAppBar } = $$props;
  let element2;
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? "main" : void 0 } = $$props;
  function getElement() {
    return element2.getElement();
  }
  $$self.$$.on_mount.push(function() {
    if (topAppBar === void 0 && !("topAppBar" in $$props || $$self.$$.bound[$$self.$$.props["topAppBar"]])) {
      console.warn("<AutoAdjust> was created without expected prop 'topAppBar'");
    }
  });
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("topAppBar" in $$new_props)
      $$invalidate(9, topAppBar = $$new_props.topAppBar);
    if ("component" in $$new_props)
      $$invalidate(2, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    get_current_component,
    forwardEventsBuilder,
    classMap,
    SmuiElement: SmuiElement_default,
    forwardEvents,
    use,
    className,
    topAppBar,
    element: element2,
    component,
    tag,
    getElement,
    propStore,
    adjustClass,
    $propStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("topAppBar" in $$props)
      $$invalidate(9, topAppBar = $$new_props.topAppBar);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("component" in $$props)
      $$invalidate(2, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(3, tag = $$new_props.tag);
    if ("propStore" in $$props)
      $$subscribe_propStore($$invalidate(4, propStore = $$new_props.propStore));
    if ("adjustClass" in $$props)
      $$invalidate(6, adjustClass = $$new_props.adjustClass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 512) {
      $:
        $$subscribe_propStore($$invalidate(4, propStore = topAppBar && topAppBar.getPropStore()));
    }
    if ($$self.$$.dirty & 2064) {
      $:
        $$invalidate(6, adjustClass = (() => {
          if (!propStore || $propStore.variant === "static") {
            return "";
          }
          if ($propStore.variant === "short") {
            return "mdc-top-app-bar--short-fixed-adjust";
          }
          if ($propStore.prominent && $propStore.dense) {
            return "mdc-top-app-bar--dense-prominent-fixed-adjust";
          }
          if ($propStore.prominent) {
            return "mdc-top-app-bar--prominent-fixed-adjust";
          }
          if ($propStore.dense) {
            return "mdc-top-app-bar--dense-fixed-adjust";
          }
          return "mdc-top-app-bar--fixed-adjust";
        })());
    }
  };
  return [
    use,
    className,
    component,
    tag,
    propStore,
    element2,
    adjustClass,
    forwardEvents,
    $$restProps,
    topAppBar,
    getElement,
    $propStore,
    slots,
    switch_instance_binding,
    $$scope
  ];
}
var AutoAdjust = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment3, safe_not_equal, {
      use: 0,
      class: 1,
      topAppBar: 9,
      component: 2,
      tag: 3,
      getElement: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AutoAdjust",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<AutoAdjust>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<AutoAdjust>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<AutoAdjust>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<AutoAdjust>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topAppBar() {
    throw new Error("<AutoAdjust>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topAppBar(value) {
    throw new Error("<AutoAdjust>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<AutoAdjust>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<AutoAdjust>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<AutoAdjust>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<AutoAdjust>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[10];
  }
  set getElement(value) {
    throw new Error("<AutoAdjust>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var AutoAdjust_default = AutoAdjust;

// node_modules/@smui/top-app-bar/dist/index.js
var dist_default = TopAppBar_default;
export {
  AutoAdjust_default as AutoAdjust,
  DenseFixedAdjust,
  DenseProminentFixedAdjust,
  FixedAdjust,
  ProminentFixedAdjust,
  Row_default as Row,
  Section_default as Section,
  ShortFixedAdjust,
  Title_default as Title,
  dist_default as default
};
//# sourceMappingURL=@smui_top-app-bar.js.map
