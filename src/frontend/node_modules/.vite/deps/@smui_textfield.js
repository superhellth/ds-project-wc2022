import "./chunk-PIAC7CRO.js";
import {
  classAdderBuilder
} from "./chunk-KTG33W7L.js";
import {
  dist_default
} from "./chunk-4L4YAOOP.js";
import {
  ContextFragment_default
} from "./chunk-OZJTW7SA.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-D34JIY7P.js";
import {
  MDCTextFieldFoundation
} from "./chunk-7WL474TB.js";
import {
  MDCNotchedOutlineFoundation
} from "./chunk-W5YFTB5Y.js";
import "./chunk-LVKEPJPU.js";
import "./chunk-WSTZOV6I.js";
import "./chunk-G23XUBRR.js";
import {
  events_exports
} from "./chunk-46WCSRWY.js";
import "./chunk-BJVEHT66.js";
import "./chunk-ZGY65EMB.js";
import {
  MDCFloatingLabelFoundation
} from "./chunk-S4ETTXGX.js";
import "./chunk-2AIYWHJH.js";
import "./chunk-JNXQATE2.js";
import {
  MDCLineRippleFoundation
} from "./chunk-EZOFSJOV.js";
import "./chunk-QKQJIKFJ.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  compute_rest_props,
  compute_slots,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_input_value,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-BJ76AV5Z.js";
import "./chunk-LNQ46MIJ.js";
import "./chunk-JC4IRQUL.js";

// node_modules/@smui/floating-label/dist/FloatingLabel.svelte
var file = "node_modules/@smui/floating-label/dist/FloatingLabel.svelte";
function create_else_block(ctx) {
  let label;
  let label_class_value;
  let label_style_value;
  let label_for_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[22].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
  let label_levels = [
    {
      class: label_class_value = classMap({
        [ctx[3]]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": ctx[0],
        "mdc-floating-label--required": ctx[1],
        ...ctx[8]
      })
    },
    {
      style: label_style_value = Object.entries(ctx[9]).map(func_1).concat([ctx[4]]).join(" ")
    },
    {
      for: label_for_value = ctx[5] || (ctx[11] ? ctx[11].id : void 0)
    },
    ctx[12]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true, style: true, for: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      add_location(label, file, 19, 2, 494);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      ctx[24](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, label, ctx[2])),
          action_destroyer(forwardEvents_action = ctx[10].call(null, label))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & 267 && label_class_value !== (label_class_value = classMap({
          [ctx2[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx2[0],
          "mdc-floating-label--required": ctx2[1],
          ...ctx2[8]
        }))) && { class: label_class_value },
        (!current || dirty & 528 && label_style_value !== (label_style_value = Object.entries(ctx2[9]).map(func_1).concat([ctx2[4]]).join(" "))) && { style: label_style_value },
        (!current || dirty & 32 && label_for_value !== (label_for_value = ctx2[5] || (ctx2[11] ? ctx2[11].id : void 0))) && { for: label_for_value },
        dirty & 4096 && ctx2[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 4)
        useActions_action.update.call(null, ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let span;
  let span_class_value;
  let span_style_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[22].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[21], null);
  let span_levels = [
    {
      class: span_class_value = classMap({
        [ctx[3]]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": ctx[0],
        "mdc-floating-label--required": ctx[1],
        ...ctx[8]
      })
    },
    {
      style: span_style_value = Object.entries(ctx[9]).map(func).concat([ctx[4]]).join(" ")
    },
    ctx[12]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file, 1, 2, 16);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[23](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, span, ctx[2])),
          action_destroyer(forwardEvents_action = ctx[10].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[21],
            !current ? get_all_dirty_from_scope(ctx2[21]) : get_slot_changes(default_slot_template, ctx2[21], dirty, null),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & 267 && span_class_value !== (span_class_value = classMap({
          [ctx2[3]]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": ctx2[0],
          "mdc-floating-label--required": ctx2[1],
          ...ctx2[8]
        }))) && { class: span_class_value },
        (!current || dirty & 528 && span_style_value !== (span_style_value = Object.entries(ctx2[9]).map(func).concat([ctx2[4]]).join(" "))) && { style: span_style_value },
        dirty & 4096 && ctx2[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 4)
        useActions_action.update.call(null, ctx2[2]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      if (default_slot)
        default_slot.d(detaching);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(1:0) {#if wrapped}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[6])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
var func_1 = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "for",
    "floatAbove",
    "required",
    "wrapped",
    "shake",
    "float",
    "setRequired",
    "getWidth",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FloatingLabel", slots, ["default"]);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { for: forId = void 0 } = $$props;
  let { floatAbove = false } = $$props;
  let { required = false } = $$props;
  let { wrapped = false } = $$props;
  let element2;
  let instance3;
  let internalClasses = {};
  let internalStyles = {};
  let inputProps = (_a = getContext("SMUI:generic:input:props")) !== null && _a !== void 0 ? _a : {};
  let previousFloatAbove = floatAbove;
  let previousRequired = required;
  onMount(() => {
    $$invalidate(18, instance3 = new MDCFloatingLabelFoundation({
      addClass,
      removeClass,
      getWidth: () => {
        var _a2, _b;
        const el = getElement();
        const clone = el.cloneNode(true);
        (_a2 = el.parentNode) === null || _a2 === void 0 ? void 0 : _a2.appendChild(clone);
        clone.classList.add("smui-floating-label--remove-transition");
        clone.classList.add("smui-floating-label--force-size");
        clone.classList.remove("mdc-floating-label--float-above");
        const scrollWidth = clone.scrollWidth;
        (_b = el.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(clone);
        return scrollWidth;
      },
      registerInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
      deregisterInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      addStyle,
      removeStyle
    };
    dispatch(element2, "SMUIFloatingLabel:mount", accessor);
    instance3.init();
    return () => {
      dispatch(element2, "SMUIFloatingLabel:unmount", accessor);
      instance3.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(9, internalStyles);
      } else {
        $$invalidate(9, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function removeStyle(name) {
    if (name in internalStyles) {
      delete internalStyles[name];
      $$invalidate(9, internalStyles);
    }
  }
  function shake(shouldShake) {
    instance3.shake(shouldShake);
  }
  function float(shouldFloat) {
    $$invalidate(0, floatAbove = shouldFloat);
  }
  function setRequired(isRequired) {
    $$invalidate(1, required = isRequired);
  }
  function getWidth() {
    return instance3.getWidth();
  }
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("for" in $$new_props)
      $$invalidate(5, forId = $$new_props.for);
    if ("floatAbove" in $$new_props)
      $$invalidate(0, floatAbove = $$new_props.floatAbove);
    if ("required" in $$new_props)
      $$invalidate(1, required = $$new_props.required);
    if ("wrapped" in $$new_props)
      $$invalidate(6, wrapped = $$new_props.wrapped);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCFloatingLabelFoundation,
    onMount,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    forwardEvents,
    use,
    className,
    style,
    forId,
    floatAbove,
    required,
    wrapped,
    element: element2,
    instance: instance3,
    internalClasses,
    internalStyles,
    inputProps,
    previousFloatAbove,
    previousRequired,
    addClass,
    removeClass,
    addStyle,
    removeStyle,
    shake,
    float,
    setRequired,
    getWidth,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("forId" in $$props)
      $$invalidate(5, forId = $$new_props.forId);
    if ("floatAbove" in $$props)
      $$invalidate(0, floatAbove = $$new_props.floatAbove);
    if ("required" in $$props)
      $$invalidate(1, required = $$new_props.required);
    if ("wrapped" in $$props)
      $$invalidate(6, wrapped = $$new_props.wrapped);
    if ("element" in $$props)
      $$invalidate(7, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(18, instance3 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(8, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(9, internalStyles = $$new_props.internalStyles);
    if ("inputProps" in $$props)
      $$invalidate(11, inputProps = $$new_props.inputProps);
    if ("previousFloatAbove" in $$props)
      $$invalidate(19, previousFloatAbove = $$new_props.previousFloatAbove);
    if ("previousRequired" in $$props)
      $$invalidate(20, previousRequired = $$new_props.previousRequired);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 786433) {
      $:
        if (instance3 && previousFloatAbove !== floatAbove) {
          $$invalidate(19, previousFloatAbove = floatAbove);
          instance3.float(floatAbove);
        }
    }
    if ($$self.$$.dirty & 1310722) {
      $:
        if (instance3 && previousRequired !== required) {
          $$invalidate(20, previousRequired = required);
          instance3.setRequired(required);
        }
    }
  };
  return [
    floatAbove,
    required,
    use,
    className,
    style,
    forId,
    wrapped,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    inputProps,
    $$restProps,
    shake,
    float,
    setRequired,
    getWidth,
    getElement,
    instance3,
    previousFloatAbove,
    previousRequired,
    $$scope,
    slots,
    span_binding,
    label_binding
  ];
}
var FloatingLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment, safe_not_equal, {
      use: 2,
      class: 3,
      style: 4,
      for: 5,
      floatAbove: 0,
      required: 1,
      wrapped: 6,
      shake: 13,
      float: 14,
      setRequired: 15,
      getWidth: 16,
      getElement: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FloatingLabel",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get for() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set for(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatAbove() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatAbove(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapped() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapped(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shake() {
    return this.$$.ctx[13];
  }
  set shake(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get float() {
    return this.$$.ctx[14];
  }
  set float(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setRequired() {
    return this.$$.ctx[15];
  }
  set setRequired(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getWidth() {
    return this.$$.ctx[16];
  }
  set getWidth(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[17];
  }
  set getElement(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FloatingLabel_default = FloatingLabel;

// node_modules/@smui/floating-label/dist/index.js
var dist_default2 = FloatingLabel_default;

// node_modules/@smui/line-ripple/dist/LineRipple.svelte
var file2 = "node_modules/@smui/line-ripple/dist/LineRipple.svelte";
function create_fragment2(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[1]]: true,
        "mdc-line-ripple": true,
        "mdc-line-ripple--active": ctx[3],
        ...ctx[5]
      })
    },
    {
      style: div_style_value = Object.entries(ctx[6]).map(func2).concat([ctx[2]]).join(" ")
    },
    ctx[8]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[13](div);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[7].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & 42 && div_class_value !== (div_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-line-ripple": true,
          "mdc-line-ripple--active": ctx2[3],
          ...ctx2[5]
        })) && { class: div_class_value },
        dirty & 68 && div_style_value !== (div_style_value = Object.entries(ctx2[6]).map(func2).concat([ctx2[2]]).join(" ")) && { style: div_style_value },
        dirty & 256 && ctx2[8]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func2 = ([name, value]) => `${name}: ${value};`;
function instance_12($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "active",
    "activate",
    "deactivate",
    "setRippleCenter",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineRipple", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { active = false } = $$props;
  let element2;
  let instance3;
  let internalClasses = {};
  let internalStyles = {};
  onMount(() => {
    instance3 = new MDCLineRippleFoundation({
      addClass,
      removeClass,
      hasClass,
      setStyle: addStyle,
      registerEventHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
      deregisterEventHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    });
    instance3.init();
    return () => {
      instance3.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(6, internalStyles);
      } else {
        $$invalidate(6, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function activate() {
    instance3.activate();
  }
  function deactivate() {
    instance3.deactivate();
  }
  function setRippleCenter(xCoordinate) {
    instance3.setRippleCenter(xCoordinate);
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("active" in $$new_props)
      $$invalidate(3, active = $$new_props.active);
  };
  $$self.$capture_state = () => ({
    MDCLineRippleFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    style,
    active,
    element: element2,
    instance: instance3,
    internalClasses,
    internalStyles,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    activate,
    deactivate,
    setRippleCenter,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("active" in $$props)
      $$invalidate(3, active = $$new_props.active);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("instance" in $$props)
      instance3 = $$new_props.instance;
    if ("internalClasses" in $$props)
      $$invalidate(5, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(6, internalStyles = $$new_props.internalStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    style,
    active,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    $$restProps,
    activate,
    deactivate,
    setRippleCenter,
    getElement,
    div_binding
  ];
}
var LineRipple = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_12, create_fragment2, safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      active: 3,
      activate: 9,
      deactivate: 10,
      setRippleCenter: 11,
      getElement: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineRipple",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activate() {
    return this.$$.ctx[9];
  }
  set activate(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deactivate() {
    return this.$$.ctx[10];
  }
  set deactivate(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setRippleCenter() {
    return this.$$.ctx[11];
  }
  set setRippleCenter(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[12];
  }
  set getElement(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineRipple_default = LineRipple;

// node_modules/@smui/line-ripple/dist/index.js
var dist_default3 = LineRipple_default;

// node_modules/@smui/notched-outline/dist/NotchedOutline.svelte
var file3 = "node_modules/@smui/notched-outline/dist/NotchedOutline.svelte";
function create_if_block2(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[13], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "mdc-notched-outline__notch");
      attr_dev(div, "style", div_style_value = Object.entries(ctx[7]).map(func3).join(" "));
      add_location(div, file3, 17, 4, 496);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[13],
            !current ? get_all_dirty_from_scope(ctx2[13]) : get_slot_changes(default_slot_template, ctx2[13], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 128 && div_style_value !== (div_style_value = Object.entries(ctx2[7]).map(func3).join(" "))) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(17:2) {#if !noLabel}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let div2_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block = !ctx[3] && create_if_block2(ctx);
  let div2_levels = [
    {
      class: div2_class_value = classMap({
        [ctx[1]]: true,
        "mdc-notched-outline": true,
        "mdc-notched-outline--notched": ctx[2],
        "mdc-notched-outline--no-label": ctx[3],
        ...ctx[6]
      })
    },
    ctx[9]
  ];
  let div2_data = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div2_data = assign(div2_data, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-notched-outline__leading");
      add_location(div0, file3, 15, 2, 430);
      attr_dev(div1, "class", "mdc-notched-outline__trailing");
      add_location(div1, file3, 26, 2, 699);
      set_attributes(div2, div2_data);
      add_location(div2, file3, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t0);
      if (if_block)
        if_block.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      ctx[15](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, div2, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[8].call(null, div2)),
          listen_dev(div2, "SMUIFloatingLabel:mount", ctx[16], false, false, false),
          listen_dev(div2, "SMUIFloatingLabel:unmount", ctx[17], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div2, div2_data = get_spread_update(div2_levels, [
        (!current || dirty & 78 && div2_class_value !== (div2_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-notched-outline": true,
          "mdc-notched-outline--notched": ctx2[2],
          "mdc-notched-outline--no-label": ctx2[3],
          ...ctx2[6]
        }))) && { class: div2_class_value },
        dirty & 512 && ctx2[9]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      if (if_block)
        if_block.d();
      ctx[15](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func3 = ([name, value]) => `${name}: ${value};`;
function instance_13($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NotchedOutline", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { notched = false } = $$props;
  let { noLabel = false } = $$props;
  let element2;
  let instance3;
  let floatingLabel;
  let internalClasses = {};
  let notchStyles = {};
  onMount(() => {
    instance3 = new MDCNotchedOutlineFoundation({
      addClass,
      removeClass,
      setNotchWidthProperty: (width) => addNotchStyle("width", width + "px"),
      removeNotchWidthProperty: () => removeNotchStyle("width")
    });
    instance3.init();
    return () => {
      instance3.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = false, internalClasses);
    }
  }
  function addNotchStyle(name, value) {
    if (notchStyles[name] != value) {
      if (value === "" || value == null) {
        delete notchStyles[name];
        $$invalidate(7, notchStyles);
      } else {
        $$invalidate(7, notchStyles[name] = value, notchStyles);
      }
    }
  }
  function removeNotchStyle(name) {
    if (name in notchStyles) {
      delete notchStyles[name];
      $$invalidate(7, notchStyles);
    }
  }
  function notch(notchWidth) {
    instance3.notch(notchWidth);
  }
  function closeNotch() {
    instance3.closeNotch();
  }
  function getElement() {
    return element2;
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  const SMUIFloatingLabel_mount_handler = (event) => $$invalidate(4, floatingLabel = event.detail);
  const SMUIFloatingLabel_unmount_handler = () => $$invalidate(4, floatingLabel = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("notched" in $$new_props)
      $$invalidate(2, notched = $$new_props.notched);
    if ("noLabel" in $$new_props)
      $$invalidate(3, noLabel = $$new_props.noLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCNotchedOutlineFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    notched,
    noLabel,
    element: element2,
    instance: instance3,
    floatingLabel,
    internalClasses,
    notchStyles,
    addClass,
    removeClass,
    addNotchStyle,
    removeNotchStyle,
    notch,
    closeNotch,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("notched" in $$props)
      $$invalidate(2, notched = $$new_props.notched);
    if ("noLabel" in $$props)
      $$invalidate(3, noLabel = $$new_props.noLabel);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("instance" in $$props)
      instance3 = $$new_props.instance;
    if ("floatingLabel" in $$props)
      $$invalidate(4, floatingLabel = $$new_props.floatingLabel);
    if ("internalClasses" in $$props)
      $$invalidate(6, internalClasses = $$new_props.internalClasses);
    if ("notchStyles" in $$props)
      $$invalidate(7, notchStyles = $$new_props.notchStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 16) {
      $:
        if (floatingLabel) {
          floatingLabel.addStyle("transition-duration", "0s");
          addClass("mdc-notched-outline--upgraded");
          requestAnimationFrame(() => {
            if (floatingLabel) {
              floatingLabel.removeStyle("transition-duration");
            }
          });
        } else {
          removeClass("mdc-notched-outline--upgraded");
        }
    }
  };
  return [
    use,
    className,
    notched,
    noLabel,
    floatingLabel,
    element2,
    internalClasses,
    notchStyles,
    forwardEvents,
    $$restProps,
    notch,
    closeNotch,
    getElement,
    $$scope,
    slots,
    div2_binding,
    SMUIFloatingLabel_mount_handler,
    SMUIFloatingLabel_unmount_handler
  ];
}
var NotchedOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_13, create_fragment3, safe_not_equal, {
      use: 0,
      class: 1,
      notched: 2,
      noLabel: 3,
      notch: 10,
      closeNotch: 11,
      getElement: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotchedOutline",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notched() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notched(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notch() {
    return this.$$.ctx[10];
  }
  set notch(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeNotch() {
    return this.$$.ctx[11];
  }
  set closeNotch(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[12];
  }
  set getElement(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NotchedOutline_default = NotchedOutline;

// node_modules/@smui/notched-outline/dist/index.js
var dist_default4 = NotchedOutline_default;

// node_modules/@smui/textfield/dist/HelperLine.js
var HelperLine_default = classAdderBuilder({
  class: "mdc-text-field-helper-line",
  tag: "div"
});

// node_modules/@smui/textfield/dist/Prefix.js
var Prefix_default = classAdderBuilder({
  class: "mdc-text-field__affix mdc-text-field__affix--prefix",
  tag: "span"
});

// node_modules/@smui/textfield/dist/Suffix.js
var Suffix_default = classAdderBuilder({
  class: "mdc-text-field__affix mdc-text-field__affix--suffix",
  tag: "span"
});

// node_modules/@smui/textfield/dist/Input.svelte
var file4 = "node_modules/@smui/textfield/dist/Input.svelte";
function create_fragment4(ctx) {
  let input;
  let input_class_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let input_levels = [
    {
      class: input_class_value = classMap({
        [ctx[1]]: true,
        "mdc-text-field__input": true
      })
    },
    { type: ctx[2] },
    { placeholder: ctx[3] },
    ctx[4],
    ctx[6],
    ctx[10]
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        placeholder: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file4, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
      ctx[26](input);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, input, ctx[0])),
          action_destroyer(forwardEvents_action = ctx[7].call(null, input)),
          listen_dev(input, "input", ctx[27], false, false, false),
          listen_dev(input, "change", ctx[9], false, false, false),
          listen_dev(input, "blur", ctx[24], false, false, false),
          listen_dev(input, "focus", ctx[25], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        dirty & 2 && input_class_value !== (input_class_value = classMap({
          [ctx2[1]]: true,
          "mdc-text-field__input": true
        })) && { class: input_class_value },
        dirty & 4 && { type: ctx2[2] },
        dirty & 8 && { placeholder: ctx2[3] },
        dirty & 16 && ctx2[4],
        dirty & 64 && ctx2[6],
        dirty & 1024 && ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 1)
        useActions_action.update.call(null, ctx2[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      ctx[26](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function toNumber(value) {
  if (value === "") {
    const nan = new Number(Number.NaN);
    nan.length = 0;
    return nan;
  }
  return +value;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "type",
    "placeholder",
    "value",
    "files",
    "dirty",
    "invalid",
    "updateInvalid",
    "emptyValueNull",
    "emptyValueUndefined",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "blur",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { type = "text" } = $$props;
  let { placeholder = " " } = $$props;
  let { value = uninitializedValue } = $$props;
  const valueUninitialized = isUninitializedValue(value);
  if (valueUninitialized) {
    value = "";
  }
  let { files = null } = $$props;
  let { dirty = false } = $$props;
  let { invalid = false } = $$props;
  let { updateInvalid = true } = $$props;
  let { emptyValueNull = value === null } = $$props;
  if (valueUninitialized && emptyValueNull) {
    value = null;
  }
  let { emptyValueUndefined = value === void 0 } = $$props;
  if (valueUninitialized && emptyValueUndefined) {
    value = void 0;
  }
  let element2;
  let internalAttrs = {};
  let valueProp = {};
  onMount(() => {
    if (updateInvalid) {
      $$invalidate(14, invalid = element2.matches(":invalid"));
    }
  });
  function valueUpdater(e) {
    if (type === "file") {
      $$invalidate(12, files = e.currentTarget.files);
      return;
    }
    if (e.currentTarget.value === "" && emptyValueNull) {
      $$invalidate(11, value = null);
      return;
    }
    if (e.currentTarget.value === "" && emptyValueUndefined) {
      $$invalidate(11, value = void 0);
      return;
    }
    switch (type) {
      case "number":
      case "range":
        $$invalidate(11, value = toNumber(e.currentTarget.value));
        break;
      default:
        $$invalidate(11, value = e.currentTarget.value);
        break;
    }
  }
  function changeHandler(e) {
    if (type === "file" || type === "range") {
      valueUpdater(e);
    }
    $$invalidate(13, dirty = true);
    if (updateInvalid) {
      $$invalidate(14, invalid = element2.matches(":invalid"));
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value2) {
    if (internalAttrs[name] !== value2) {
      $$invalidate(6, internalAttrs[name] = value2, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(6, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function focus() {
    getElement().focus();
  }
  function blur() {
    getElement().blur();
  }
  function getElement() {
    return element2;
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  const input_handler = (e) => type !== "file" && valueUpdater(e);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("type" in $$new_props)
      $$invalidate(2, type = $$new_props.type);
    if ("placeholder" in $$new_props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("value" in $$new_props)
      $$invalidate(11, value = $$new_props.value);
    if ("files" in $$new_props)
      $$invalidate(12, files = $$new_props.files);
    if ("dirty" in $$new_props)
      $$invalidate(13, dirty = $$new_props.dirty);
    if ("invalid" in $$new_props)
      $$invalidate(14, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
    if ("emptyValueNull" in $$new_props)
      $$invalidate(16, emptyValueNull = $$new_props.emptyValueNull);
    if ("emptyValueUndefined" in $$new_props)
      $$invalidate(17, emptyValueUndefined = $$new_props.emptyValueUndefined);
  };
  $$self.$capture_state = () => ({
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    type,
    placeholder,
    value,
    valueUninitialized,
    files,
    dirty,
    invalid,
    updateInvalid,
    emptyValueNull,
    emptyValueUndefined,
    element: element2,
    internalAttrs,
    valueProp,
    toNumber,
    valueUpdater,
    changeHandler,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("type" in $$props)
      $$invalidate(2, type = $$new_props.type);
    if ("placeholder" in $$props)
      $$invalidate(3, placeholder = $$new_props.placeholder);
    if ("value" in $$props)
      $$invalidate(11, value = $$new_props.value);
    if ("files" in $$props)
      $$invalidate(12, files = $$new_props.files);
    if ("dirty" in $$props)
      $$invalidate(13, dirty = $$new_props.dirty);
    if ("invalid" in $$props)
      $$invalidate(14, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$props)
      $$invalidate(15, updateInvalid = $$new_props.updateInvalid);
    if ("emptyValueNull" in $$props)
      $$invalidate(16, emptyValueNull = $$new_props.emptyValueNull);
    if ("emptyValueUndefined" in $$props)
      $$invalidate(17, emptyValueUndefined = $$new_props.emptyValueUndefined);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("internalAttrs" in $$props)
      $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
    if ("valueProp" in $$props)
      $$invalidate(4, valueProp = $$new_props.valueProp);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2068) {
      $:
        if (type === "file") {
          delete valueProp.value;
          $$invalidate(4, valueProp), $$invalidate(2, type), $$invalidate(11, value);
        } else {
          $$invalidate(4, valueProp.value = value == null ? "" : value, valueProp);
        }
    }
  };
  return [
    use,
    className,
    type,
    placeholder,
    valueProp,
    element2,
    internalAttrs,
    forwardEvents,
    valueUpdater,
    changeHandler,
    $$restProps,
    value,
    files,
    dirty,
    invalid,
    updateInvalid,
    emptyValueNull,
    emptyValueUndefined,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement,
    blur_handler,
    focus_handler,
    input_binding,
    input_handler
  ];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment4, safe_not_equal, {
      use: 0,
      class: 1,
      type: 2,
      placeholder: 3,
      value: 11,
      files: 12,
      dirty: 13,
      invalid: 14,
      updateInvalid: 15,
      emptyValueNull: 16,
      emptyValueUndefined: 17,
      getAttr: 18,
      addAttr: 19,
      removeAttr: 20,
      focus: 21,
      blur: 22,
      getElement: 23
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dirty() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dirty(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateInvalid() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateInvalid(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get emptyValueNull() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set emptyValueNull(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get emptyValueUndefined() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set emptyValueUndefined(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getAttr() {
    return this.$$.ctx[18];
  }
  set getAttr(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addAttr() {
    return this.$$.ctx[19];
  }
  set addAttr(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeAttr() {
    return this.$$.ctx[20];
  }
  set removeAttr(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[21];
  }
  set focus(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    return this.$$.ctx[22];
  }
  set blur(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[23];
  }
  set getElement(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/@smui/textfield/dist/Textarea.svelte
var file5 = "node_modules/@smui/textfield/dist/Textarea.svelte";
function create_fragment5(ctx) {
  let textarea;
  let textarea_class_value;
  let textarea_style_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let textarea_levels = [
    {
      class: textarea_class_value = classMap({
        [ctx[2]]: true,
        "mdc-text-field__input": true
      })
    },
    {
      style: textarea_style_value = `${ctx[4] ? "" : "resize: none; "}${ctx[3]}`
    },
    ctx[6],
    ctx[9]
  ];
  let textarea_data = {};
  for (let i = 0; i < textarea_levels.length; i += 1) {
    textarea_data = assign(textarea_data, textarea_levels[i]);
  }
  const block = {
    c: function create() {
      textarea = element("textarea");
      this.h();
    },
    l: function claim(nodes) {
      textarea = claim_element(nodes, "TEXTAREA", { class: true, style: true });
      children(textarea).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(textarea, textarea_data);
      add_location(textarea, file5, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, textarea, anchor);
      if (textarea.autofocus)
        textarea.focus();
      ctx[21](textarea);
      set_input_value(textarea, ctx[0]);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(null, textarea, ctx[1])),
          action_destroyer(forwardEvents_action = ctx[7].call(null, textarea)),
          listen_dev(textarea, "change", ctx[8], false, false, false),
          listen_dev(textarea, "blur", ctx[19], false, false, false),
          listen_dev(textarea, "focus", ctx[20], false, false, false),
          listen_dev(textarea, "input", ctx[22])
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(textarea, textarea_data = get_spread_update(textarea_levels, [
        dirty & 4 && textarea_class_value !== (textarea_class_value = classMap({
          [ctx2[2]]: true,
          "mdc-text-field__input": true
        })) && { class: textarea_class_value },
        dirty & 24 && textarea_style_value !== (textarea_style_value = `${ctx2[4] ? "" : "resize: none; "}${ctx2[3]}`) && { style: textarea_style_value },
        dirty & 64 && ctx2[6],
        dirty & 512 && ctx2[9]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & 2)
        useActions_action.update.call(null, ctx2[1]);
      if (dirty & 1) {
        set_input_value(textarea, ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(textarea);
      ctx[21](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "value",
    "dirty",
    "invalid",
    "updateInvalid",
    "resizable",
    "getAttr",
    "addAttr",
    "removeAttr",
    "focus",
    "blur",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Textarea", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { value = "" } = $$props;
  let { dirty = false } = $$props;
  let { invalid = false } = $$props;
  let { updateInvalid = true } = $$props;
  let { resizable = true } = $$props;
  let element2;
  let internalAttrs = {};
  onMount(() => {
    if (updateInvalid) {
      $$invalidate(11, invalid = element2.matches(":invalid"));
    }
  });
  function changeHandler() {
    $$invalidate(10, dirty = true);
    if (updateInvalid) {
      $$invalidate(11, invalid = element2.matches(":invalid"));
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value2) {
    if (internalAttrs[name] !== value2) {
      $$invalidate(6, internalAttrs[name] = value2, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(6, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function focus() {
    getElement().focus();
  }
  function blur() {
    getElement().blur();
  }
  function getElement() {
    return element2;
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(3, style = $$new_props.style);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("dirty" in $$new_props)
      $$invalidate(10, dirty = $$new_props.dirty);
    if ("invalid" in $$new_props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
    if ("resizable" in $$new_props)
      $$invalidate(4, resizable = $$new_props.resizable);
  };
  $$self.$capture_state = () => ({
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    style,
    value,
    dirty,
    invalid,
    updateInvalid,
    resizable,
    element: element2,
    internalAttrs,
    changeHandler,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(3, style = $$new_props.style);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("dirty" in $$props)
      $$invalidate(10, dirty = $$new_props.dirty);
    if ("invalid" in $$props)
      $$invalidate(11, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$props)
      $$invalidate(12, updateInvalid = $$new_props.updateInvalid);
    if ("resizable" in $$props)
      $$invalidate(4, resizable = $$new_props.resizable);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("internalAttrs" in $$props)
      $$invalidate(6, internalAttrs = $$new_props.internalAttrs);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    use,
    className,
    style,
    resizable,
    element2,
    internalAttrs,
    forwardEvents,
    changeHandler,
    $$restProps,
    dirty,
    invalid,
    updateInvalid,
    getAttr,
    addAttr,
    removeAttr,
    focus,
    blur,
    getElement,
    blur_handler,
    focus_handler,
    textarea_binding,
    textarea_input_handler
  ];
}
var Textarea = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment5, safe_not_equal, {
      use: 1,
      class: 2,
      style: 3,
      value: 0,
      dirty: 10,
      invalid: 11,
      updateInvalid: 12,
      resizable: 4,
      getAttr: 13,
      addAttr: 14,
      removeAttr: 15,
      focus: 16,
      blur: 17,
      getElement: 18
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textarea",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dirty() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dirty(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateInvalid() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateInvalid(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resizable() {
    throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resizable(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getAttr() {
    return this.$$.ctx[13];
  }
  set getAttr(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addAttr() {
    return this.$$.ctx[14];
  }
  set addAttr(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeAttr() {
    return this.$$.ctx[15];
  }
  set removeAttr(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[16];
  }
  set focus(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    return this.$$.ctx[17];
  }
  set blur(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[18];
  }
  set getElement(value) {
    throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Textarea_default = Textarea;

// node_modules/@smui/textfield/dist/Textfield.svelte
var { Error: Error_1 } = globals;
var file6 = "node_modules/@smui/textfield/dist/Textfield.svelte";
var get_helper_slot_changes = (dirty) => ({});
var get_helper_slot_context = (ctx) => ({});
var get_ripple_slot_changes = (dirty) => ({});
var get_ripple_slot_context = (ctx) => ({});
var get_trailingIcon_slot_changes_1 = (dirty) => ({});
var get_trailingIcon_slot_context_1 = (ctx) => ({});
var get_leadingIcon_slot_changes_1 = (dirty) => ({});
var get_leadingIcon_slot_context_1 = (ctx) => ({});
var get_label_slot_changes_2 = (dirty) => ({});
var get_label_slot_context_2 = (ctx) => ({});
var get_trailingIcon_slot_changes = (dirty) => ({});
var get_trailingIcon_slot_context = (ctx) => ({});
var get_suffix_slot_changes = (dirty) => ({});
var get_suffix_slot_context = (ctx) => ({});
var get_prefix_slot_changes = (dirty) => ({});
var get_prefix_slot_context = (ctx) => ({});
var get_internalCounter_slot_changes = (dirty) => ({});
var get_internalCounter_slot_context = (ctx) => ({});
var get_leadingIcon_slot_changes = (dirty) => ({});
var get_leadingIcon_slot_context = (ctx) => ({});
var get_label_slot_changes_1 = (dirty) => ({});
var get_label_slot_context_1 = (ctx) => ({});
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_else_block_1(ctx) {
  let div;
  let t0;
  let contextfragment0;
  let t1;
  let t2;
  let contextfragment1;
  let t3;
  let div_class_value;
  let div_style_value;
  let Ripple_action;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const label_slot_template = ctx[51].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[90], get_label_slot_context_2);
  contextfragment0 = new ContextFragment_default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: true,
      $$slots: { default: [create_default_slot_9] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const default_slot_template = ctx[51].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[90], null);
  contextfragment1 = new ContextFragment_default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: false,
      $$slots: { default: [create_default_slot_8] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const ripple_slot_template = ctx[51].ripple;
  const ripple_slot = create_slot(ripple_slot_template, ctx, ctx[90], get_ripple_slot_context);
  let div_levels = [
    {
      class: div_class_value = classMap({
        [ctx[9]]: true,
        "mdc-text-field": true,
        "mdc-text-field--disabled": ctx[12],
        "mdc-text-field--textarea": ctx[14],
        "mdc-text-field--filled": ctx[15] === "filled",
        "mdc-text-field--outlined": ctx[15] === "outlined",
        "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
        "mdc-text-field--no-label": ctx[16] || !ctx[42].label,
        "mdc-text-field--with-leading-icon": ctx[42].leadingIcon,
        "mdc-text-field--with-trailing-icon": ctx[42].trailingIcon,
        "mdc-text-field--invalid": ctx[1],
        ...ctx[25]
      })
    },
    {
      style: div_style_value = Object.entries(ctx[26]).map(func_12).concat([ctx[10]]).join(" ")
    },
    exclude(ctx[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if (label_slot)
        label_slot.c();
      t0 = space();
      create_component(contextfragment0.$$.fragment);
      t1 = space();
      if (default_slot)
        default_slot.c();
      t2 = space();
      create_component(contextfragment1.$$.fragment);
      t3 = space();
      if (ripple_slot)
        ripple_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (label_slot)
        label_slot.l(div_nodes);
      t0 = claim_space(div_nodes);
      claim_component(contextfragment0.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      if (default_slot)
        default_slot.l(div_nodes);
      t2 = claim_space(div_nodes);
      claim_component(contextfragment1.$$.fragment, div_nodes);
      t3 = claim_space(div_nodes);
      if (ripple_slot)
        ripple_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file6, 163, 2, 5417);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (label_slot) {
        label_slot.m(div, null);
      }
      append_hydration_dev(div, t0);
      mount_component(contextfragment0, div, null);
      append_hydration_dev(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append_hydration_dev(div, t2);
      mount_component(contextfragment1, div, null);
      append_hydration_dev(div, t3);
      if (ripple_slot) {
        ripple_slot.m(div, null);
      }
      ctx[80](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(Ripple_action = dist_default.call(null, div, {
            ripple: ctx[11],
            unbounded: false,
            addClass: ctx[38],
            removeClass: ctx[39],
            addStyle: ctx[40]
          })),
          action_destroyer(useActions_action = useActions.call(null, div, ctx[8])),
          action_destroyer(forwardEvents_action = ctx[34].call(null, div)),
          listen_dev(div, "SMUITextfieldLeadingIcon:mount", ctx[81], false, false, false),
          listen_dev(div, "SMUITextfieldLeadingIcon:unmount", ctx[82], false, false, false),
          listen_dev(div, "SMUITextfieldTrailingIcon:mount", ctx[83], false, false, false),
          listen_dev(div, "SMUITextfieldTrailingIcon:unmount", ctx[84], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(label_slot_template, ctx2[90], dirty, get_label_slot_changes_2),
            get_label_slot_context_2
          );
        }
      }
      const contextfragment0_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment0.$set(contextfragment0_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(default_slot_template, ctx2[90], dirty, null),
            null
          );
        }
      }
      const contextfragment1_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment1.$set(contextfragment1_changes);
      if (ripple_slot) {
        if (ripple_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            ripple_slot,
            ripple_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(ripple_slot_template, ctx2[90], dirty, get_ripple_slot_changes),
            get_ripple_slot_context
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & 33673730 | dirty[1] & 2048 && div_class_value !== (div_class_value = classMap({
          [ctx2[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx2[12],
          "mdc-text-field--textarea": ctx2[14],
          "mdc-text-field--filled": ctx2[15] === "filled",
          "mdc-text-field--outlined": ctx2[15] === "outlined",
          "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
          "mdc-text-field--no-label": ctx2[16] || !ctx2[42].label,
          "mdc-text-field--with-leading-icon": ctx2[42].leadingIcon,
          "mdc-text-field--with-trailing-icon": ctx2[42].trailingIcon,
          "mdc-text-field--invalid": ctx2[1],
          ...ctx2[25]
        }))) && { class: div_class_value },
        (!current || dirty[0] & 67109888 && div_style_value !== (div_style_value = Object.entries(ctx2[26]).map(func_12).concat([ctx2[10]]).join(" "))) && { style: div_style_value },
        dirty[1] & 1024 && exclude(ctx2[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 2048)
        Ripple_action.update.call(null, {
          ripple: ctx2[11],
          unbounded: false,
          addClass: ctx2[38],
          removeClass: ctx2[39],
          addStyle: ctx2[40]
        });
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
        useActions_action.update.call(null, ctx2[8]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      transition_in(contextfragment0.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(contextfragment1.$$.fragment, local);
      transition_in(ripple_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      transition_out(contextfragment0.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(contextfragment1.$$.fragment, local);
      transition_out(ripple_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (label_slot)
        label_slot.d(detaching);
      destroy_component(contextfragment0);
      if (default_slot)
        default_slot.d(detaching);
      destroy_component(contextfragment1);
      if (ripple_slot)
        ripple_slot.d(detaching);
      ctx[80](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(163:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let label_1;
  let t0;
  let t1;
  let contextfragment0;
  let t2;
  let t3;
  let current_block_type_index;
  let if_block2;
  let t4;
  let contextfragment1;
  let t5;
  let label_1_class_value;
  let label_1_style_value;
  let Ripple_action;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !ctx[14] && ctx[15] !== "outlined" && create_if_block_8(ctx);
  let if_block1 = (ctx[14] || ctx[15] === "outlined") && create_if_block_6(ctx);
  contextfragment0 = new ContextFragment_default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: true,
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const default_slot_template = ctx[51].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[90], null);
  const if_block_creators = [create_if_block_3, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (ctx2[14] && typeof ctx2[0] === "string")
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1]);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  contextfragment1 = new ContextFragment_default({
    props: {
      key: "SMUI:textfield:icon:leading",
      value: false,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block3 = !ctx[14] && ctx[15] !== "outlined" && ctx[11] && create_if_block_2(ctx);
  let label_1_levels = [
    {
      class: label_1_class_value = classMap({
        [ctx[9]]: true,
        "mdc-text-field": true,
        "mdc-text-field--disabled": ctx[12],
        "mdc-text-field--textarea": ctx[14],
        "mdc-text-field--filled": ctx[15] === "filled",
        "mdc-text-field--outlined": ctx[15] === "outlined",
        "smui-text-field--standard": ctx[15] === "standard" && !ctx[14],
        "mdc-text-field--no-label": ctx[16] || ctx[17] == null && !ctx[42].label,
        "mdc-text-field--label-floating": ctx[28] || ctx[0] != null && ctx[0] !== "",
        "mdc-text-field--with-leading-icon": ctx[35](ctx[22]) ? ctx[42].leadingIcon : ctx[22],
        "mdc-text-field--with-trailing-icon": ctx[35](ctx[23]) ? ctx[42].trailingIcon : ctx[23],
        "mdc-text-field--with-internal-counter": ctx[14] && ctx[42].internalCounter,
        "mdc-text-field--invalid": ctx[1],
        ...ctx[25]
      })
    },
    {
      style: label_1_style_value = Object.entries(ctx[26]).map(func4).concat([ctx[10]]).join(" ")
    },
    {
      for: void 0
    },
    exclude(ctx[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
  ];
  let label_1_data = {};
  for (let i = 0; i < label_1_levels.length; i += 1) {
    label_1_data = assign(label_1_data, label_1_levels[i]);
  }
  const block = {
    c: function create() {
      label_1 = element("label");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      create_component(contextfragment0.$$.fragment);
      t2 = space();
      if (default_slot)
        default_slot.c();
      t3 = space();
      if_block2.c();
      t4 = space();
      create_component(contextfragment1.$$.fragment);
      t5 = space();
      if (if_block3)
        if_block3.c();
      this.h();
    },
    l: function claim(nodes) {
      label_1 = claim_element(nodes, "LABEL", { class: true, style: true, for: true });
      var label_1_nodes = children(label_1);
      if (if_block0)
        if_block0.l(label_1_nodes);
      t0 = claim_space(label_1_nodes);
      if (if_block1)
        if_block1.l(label_1_nodes);
      t1 = claim_space(label_1_nodes);
      claim_component(contextfragment0.$$.fragment, label_1_nodes);
      t2 = claim_space(label_1_nodes);
      if (default_slot)
        default_slot.l(label_1_nodes);
      t3 = claim_space(label_1_nodes);
      if_block2.l(label_1_nodes);
      t4 = claim_space(label_1_nodes);
      claim_component(contextfragment1.$$.fragment, label_1_nodes);
      t5 = claim_space(label_1_nodes);
      if (if_block3)
        if_block3.l(label_1_nodes);
      label_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label_1, label_1_data);
      add_location(label_1, file6, 1, 2, 15);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label_1, anchor);
      if (if_block0)
        if_block0.m(label_1, null);
      append_hydration_dev(label_1, t0);
      if (if_block1)
        if_block1.m(label_1, null);
      append_hydration_dev(label_1, t1);
      mount_component(contextfragment0, label_1, null);
      append_hydration_dev(label_1, t2);
      if (default_slot) {
        default_slot.m(label_1, null);
      }
      append_hydration_dev(label_1, t3);
      if_blocks[current_block_type_index].m(label_1, null);
      append_hydration_dev(label_1, t4);
      mount_component(contextfragment1, label_1, null);
      append_hydration_dev(label_1, t5);
      if (if_block3)
        if_block3.m(label_1, null);
      ctx[73](label_1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(Ripple_action = dist_default.call(null, label_1, {
            ripple: !ctx[14] && ctx[15] === "filled",
            unbounded: false,
            addClass: ctx[38],
            removeClass: ctx[39],
            addStyle: ctx[40],
            eventTarget: ctx[33],
            activeTarget: ctx[33],
            initPromise: ctx[37]
          })),
          action_destroyer(useActions_action = useActions.call(null, label_1, ctx[8])),
          action_destroyer(forwardEvents_action = ctx[34].call(null, label_1)),
          listen_dev(label_1, "SMUITextfieldLeadingIcon:mount", ctx[74], false, false, false),
          listen_dev(label_1, "SMUITextfieldLeadingIcon:unmount", ctx[75], false, false, false),
          listen_dev(label_1, "SMUITextfieldTrailingIcon:mount", ctx[76], false, false, false),
          listen_dev(label_1, "SMUITextfieldTrailingIcon:unmount", ctx[77], false, false, false),
          listen_dev(label_1, "SMUITextfieldCharacterCounter:mount", ctx[78], false, false, false),
          listen_dev(label_1, "SMUITextfieldCharacterCounter:unmount", ctx[79], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[14] && ctx2[15] !== "outlined") {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 49152) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(label_1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[14] || ctx2[15] === "outlined") {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 49152) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(label_1, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const contextfragment0_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment0.$set(contextfragment0_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(default_slot_template, ctx2[90], dirty, null),
            null
          );
        }
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block2.c();
        } else {
          if_block2.p(ctx2, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(label_1, t4);
      }
      const contextfragment1_changes = {};
      if (dirty[2] & 268435456) {
        contextfragment1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      contextfragment1.$set(contextfragment1_changes);
      if (!ctx2[14] && ctx2[15] !== "outlined" && ctx2[11]) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & 51200) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(label_1, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      set_attributes(label_1, label_1_data = get_spread_update(label_1_levels, [
        (!current || dirty[0] & 314823171 | dirty[1] & 2048 && label_1_class_value !== (label_1_class_value = classMap({
          [ctx2[9]]: true,
          "mdc-text-field": true,
          "mdc-text-field--disabled": ctx2[12],
          "mdc-text-field--textarea": ctx2[14],
          "mdc-text-field--filled": ctx2[15] === "filled",
          "mdc-text-field--outlined": ctx2[15] === "outlined",
          "smui-text-field--standard": ctx2[15] === "standard" && !ctx2[14],
          "mdc-text-field--no-label": ctx2[16] || ctx2[17] == null && !ctx2[42].label,
          "mdc-text-field--label-floating": ctx2[28] || ctx2[0] != null && ctx2[0] !== "",
          "mdc-text-field--with-leading-icon": ctx2[35](ctx2[22]) ? ctx2[42].leadingIcon : ctx2[22],
          "mdc-text-field--with-trailing-icon": ctx2[35](ctx2[23]) ? ctx2[42].trailingIcon : ctx2[23],
          "mdc-text-field--with-internal-counter": ctx2[14] && ctx2[42].internalCounter,
          "mdc-text-field--invalid": ctx2[1],
          ...ctx2[25]
        }))) && { class: label_1_class_value },
        (!current || dirty[0] & 67109888 && label_1_style_value !== (label_1_style_value = Object.entries(ctx2[26]).map(func4).concat([ctx2[10]]).join(" "))) && { style: label_1_style_value },
        {
          for: void 0
        },
        dirty[1] & 1024 && exclude(ctx2[41], ["input$", "label$", "ripple$", "outline$", "helperLine$"])
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & 49152 | dirty[1] & 4)
        Ripple_action.update.call(null, {
          ripple: !ctx2[14] && ctx2[15] === "filled",
          unbounded: false,
          addClass: ctx2[38],
          removeClass: ctx2[39],
          addStyle: ctx2[40],
          eventTarget: ctx2[33],
          activeTarget: ctx2[33],
          initPromise: ctx2[37]
        });
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & 256)
        useActions_action.update.call(null, ctx2[8]);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(contextfragment0.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(if_block2);
      transition_in(contextfragment1.$$.fragment, local);
      transition_in(if_block3);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(contextfragment0.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(if_block2);
      transition_out(contextfragment1.$$.fragment, local);
      transition_out(if_block3);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label_1);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(contextfragment0);
      if (default_slot)
        default_slot.d(detaching);
      if_blocks[current_block_type_index].d();
      destroy_component(contextfragment1);
      if (if_block3)
        if_block3.d();
      ctx[73](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(1:0) {#if valued}",
    ctx
  });
  return block;
}
function create_default_slot_9(ctx) {
  let current;
  const leadingIcon_slot_template = ctx[51].leadingIcon;
  const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[90], get_leadingIcon_slot_context_1);
  const block = {
    c: function create() {
      if (leadingIcon_slot)
        leadingIcon_slot.c();
    },
    l: function claim(nodes) {
      if (leadingIcon_slot)
        leadingIcon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (leadingIcon_slot) {
        leadingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (leadingIcon_slot) {
        if (leadingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            leadingIcon_slot,
            leadingIcon_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(leadingIcon_slot_template, ctx2[90], dirty, get_leadingIcon_slot_changes_1),
            get_leadingIcon_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(leadingIcon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(leadingIcon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (leadingIcon_slot)
        leadingIcon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_9.name,
    type: "slot",
    source: '(207:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={true}>',
    ctx
  });
  return block;
}
function create_default_slot_8(ctx) {
  let current;
  const trailingIcon_slot_template = ctx[51].trailingIcon;
  const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[90], get_trailingIcon_slot_context_1);
  const block = {
    c: function create() {
      if (trailingIcon_slot)
        trailingIcon_slot.c();
    },
    l: function claim(nodes) {
      if (trailingIcon_slot)
        trailingIcon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (trailingIcon_slot) {
        trailingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trailingIcon_slot) {
        if (trailingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            trailingIcon_slot,
            trailingIcon_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(trailingIcon_slot_template, ctx2[90], dirty, get_trailingIcon_slot_changes_1),
            get_trailingIcon_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trailingIcon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trailingIcon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (trailingIcon_slot)
        trailingIcon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_8.name,
    type: "slot",
    source: '(211:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={false}>',
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = ctx[15] === "filled" && create_if_block_10(ctx);
  let if_block1 = !ctx[16] && (ctx[17] != null || ctx[42].label) && create_if_block_9(ctx);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0)
        if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[15] === "filled") {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          if_block0.m(t.parentNode, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!ctx2[16] && (ctx2[17] != null || ctx2[42].label)) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 196608 | dirty[1] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_9(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(62:4) {#if !textarea && variant !== 'outlined'}",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "mdc-text-field__ripple");
      add_location(span, file6, 63, 8, 2241);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(63:6) {#if variant === 'filled'}",
    ctx
  });
  return block;
}
function create_if_block_9(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    {
      floatAbove: ctx[28] || ctx[0] != null && ctx[0] !== ""
    },
    { required: ctx[13] },
    { wrapped: true },
    prefixFilter(ctx[41], "label$")
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_7] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new dist_default2({
    props: floatinglabel_props,
    $$inline: true
  });
  ctx[52](floatinglabel);
  const block = {
    c: function create() {
      create_component(floatinglabel.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(floatinglabel.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & 268443649 | dirty[1] & 1024 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & 268435457 && {
          floatAbove: ctx2[28] || ctx2[0] != null && ctx2[0] !== ""
        },
        dirty[0] & 8192 && { required: ctx2[13] },
        floatinglabel_spread_levels[2],
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "label$"))
      ]) : {};
      if (dirty[0] & 131072 | dirty[2] & 268435456) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[52](null);
      destroy_component(floatinglabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(66:6) {#if !noLabel && (label != null || $$slots.label)}",
    ctx
  });
  return block;
}
function create_default_slot_7(ctx) {
  let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
  let t;
  let current;
  const label_slot_template = ctx[51].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[90], get_label_slot_context);
  const block = {
    c: function create() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
      if (label_slot)
        label_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
        set_data_dev(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(label_slot_template, ctx2[90], dirty, get_label_slot_changes),
            get_label_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_7.name,
    type: "slot",
    source: "(67:8) <FloatingLabel           bind:this={floatingLabel}           floatAbove={focused || (value != null && value !== '')}           {required}           wrapped           {...prefixFilter($$restProps, 'label$')}           >",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let notchedoutline;
  let current;
  const notchedoutline_spread_levels = [
    {
      noLabel: ctx[16] || ctx[17] == null && !ctx[42].label
    },
    prefixFilter(ctx[41], "outline$")
  ];
  let notchedoutline_props = {
    $$slots: { default: [create_default_slot_5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
    notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
  }
  notchedoutline = new dist_default4({
    props: notchedoutline_props,
    $$inline: true
  });
  ctx[54](notchedoutline);
  const block = {
    c: function create() {
      create_component(notchedoutline.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(notchedoutline.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(notchedoutline, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notchedoutline_changes = dirty[0] & 196608 | dirty[1] & 3072 ? get_spread_update(notchedoutline_spread_levels, [
        dirty[0] & 196608 | dirty[1] & 2048 && {
          noLabel: ctx2[16] || ctx2[17] == null && !ctx2[42].label
        },
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "outline$"))
      ]) : {};
      if (dirty[0] & 268640289 | dirty[1] & 3072 | dirty[2] & 268435456) {
        notchedoutline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notchedoutline.$set(notchedoutline_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notchedoutline.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notchedoutline.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[54](null);
      destroy_component(notchedoutline, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(77:4) {#if textarea || variant === 'outlined'}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    {
      floatAbove: ctx[28] || ctx[0] != null && ctx[0] !== ""
    },
    { required: ctx[13] },
    { wrapped: true },
    prefixFilter(ctx[41], "label$")
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_6] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new dist_default2({
    props: floatinglabel_props,
    $$inline: true
  });
  ctx[53](floatinglabel);
  const block = {
    c: function create() {
      create_component(floatinglabel.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(floatinglabel.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & 268443649 | dirty[1] & 1024 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & 268435457 && {
          floatAbove: ctx2[28] || ctx2[0] != null && ctx2[0] !== ""
        },
        dirty[0] & 8192 && { required: ctx2[13] },
        floatinglabel_spread_levels[2],
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "label$"))
      ]) : {};
      if (dirty[0] & 131072 | dirty[2] & 268435456) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[53](null);
      destroy_component(floatinglabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(83:8) {#if !noLabel && (label != null || $$slots.label)}",
    ctx
  });
  return block;
}
function create_default_slot_6(ctx) {
  let t_value = (ctx[17] == null ? "" : ctx[17]) + "";
  let t;
  let current;
  const label_slot_template = ctx[51].label;
  const label_slot = create_slot(label_slot_template, ctx, ctx[90], get_label_slot_context_1);
  const block = {
    c: function create() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
      if (label_slot)
        label_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & 131072) && t_value !== (t_value = (ctx2[17] == null ? "" : ctx2[17]) + ""))
        set_data_dev(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(label_slot_template, ctx2[90], dirty, get_label_slot_changes_1),
            get_label_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_6.name,
    type: "slot",
    source: "(84:10) <FloatingLabel             bind:this={floatingLabel}             floatAbove={focused || (value != null && value !== '')}             {required}             wrapped             {...prefixFilter($$restProps, 'label$')}             >",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !ctx[16] && (ctx[17] != null || ctx[42].label) && create_if_block_7(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[16] && (ctx2[17] != null || ctx2[42].label)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 196608 | dirty[1] & 2048) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(78:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let current;
  const leadingIcon_slot_template = ctx[51].leadingIcon;
  const leadingIcon_slot = create_slot(leadingIcon_slot_template, ctx, ctx[90], get_leadingIcon_slot_context);
  const block = {
    c: function create() {
      if (leadingIcon_slot)
        leadingIcon_slot.c();
    },
    l: function claim(nodes) {
      if (leadingIcon_slot)
        leadingIcon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (leadingIcon_slot) {
        leadingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (leadingIcon_slot) {
        if (leadingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            leadingIcon_slot,
            leadingIcon_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(leadingIcon_slot_template, ctx2[90], dirty, get_leadingIcon_slot_changes),
            get_leadingIcon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(leadingIcon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(leadingIcon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (leadingIcon_slot)
        leadingIcon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: '(95:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={true}>',
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let t0;
  let t1;
  let input_1;
  let updating_value;
  let updating_files;
  let updating_dirty;
  let updating_invalid;
  let t2;
  let t3;
  let current;
  const prefix_slot_template = ctx[51].prefix;
  const prefix_slot = create_slot(prefix_slot_template, ctx, ctx[90], get_prefix_slot_context);
  let if_block0 = ctx[20] != null && create_if_block_5(ctx);
  const input_1_spread_levels = [
    { type: ctx[18] },
    { disabled: ctx[12] },
    { required: ctx[13] },
    { updateInvalid: ctx[19] },
    { "aria-controls": ctx[27] },
    { "aria-describedby": ctx[27] },
    ctx[16] && ctx[17] != null ? { placeholder: ctx[17] } : {},
    prefixFilter(ctx[41], "input$")
  ];
  function input_1_value_binding(value) {
    ctx[64](value);
  }
  function input_1_files_binding(value) {
    ctx[65](value);
  }
  function input_1_dirty_binding(value) {
    ctx[66](value);
  }
  function input_1_invalid_binding(value) {
    ctx[67](value);
  }
  let input_1_props = {};
  for (let i = 0; i < input_1_spread_levels.length; i += 1) {
    input_1_props = assign(input_1_props, input_1_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    input_1_props.value = ctx[0];
  }
  if (ctx[3] !== void 0) {
    input_1_props.files = ctx[3];
  }
  if (ctx[4] !== void 0) {
    input_1_props.dirty = ctx[4];
  }
  if (ctx[1] !== void 0) {
    input_1_props.invalid = ctx[1];
  }
  input_1 = new Input_default({ props: input_1_props, $$inline: true });
  ctx[63](input_1);
  binding_callbacks.push(() => bind(input_1, "value", input_1_value_binding));
  binding_callbacks.push(() => bind(input_1, "files", input_1_files_binding));
  binding_callbacks.push(() => bind(input_1, "dirty", input_1_dirty_binding));
  binding_callbacks.push(() => bind(input_1, "invalid", input_1_invalid_binding));
  input_1.$on("blur", ctx[68]);
  input_1.$on("focus", ctx[69]);
  input_1.$on("blur", ctx[70]);
  input_1.$on("focus", ctx[71]);
  let if_block1 = ctx[21] != null && create_if_block_4(ctx);
  const suffix_slot_template = ctx[51].suffix;
  const suffix_slot = create_slot(suffix_slot_template, ctx, ctx[90], get_suffix_slot_context);
  const block = {
    c: function create() {
      if (prefix_slot)
        prefix_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      create_component(input_1.$$.fragment);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (suffix_slot)
        suffix_slot.c();
    },
    l: function claim(nodes) {
      if (prefix_slot)
        prefix_slot.l(nodes);
      t0 = claim_space(nodes);
      if (if_block0)
        if_block0.l(nodes);
      t1 = claim_space(nodes);
      claim_component(input_1.$$.fragment, nodes);
      t2 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t3 = claim_space(nodes);
      if (suffix_slot)
        suffix_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (prefix_slot) {
        prefix_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t0, anchor);
      if (if_block0)
        if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(input_1, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (suffix_slot) {
        suffix_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (prefix_slot) {
        if (prefix_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            prefix_slot,
            prefix_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(prefix_slot_template, ctx2[90], dirty, get_prefix_slot_changes),
            get_prefix_slot_context
          );
        }
      }
      if (ctx2[20] != null) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & 1048576) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const input_1_changes = dirty[0] & 135213056 | dirty[1] & 1024 ? get_spread_update(input_1_spread_levels, [
        dirty[0] & 262144 && { type: ctx2[18] },
        dirty[0] & 4096 && { disabled: ctx2[12] },
        dirty[0] & 8192 && { required: ctx2[13] },
        dirty[0] & 524288 && { updateInvalid: ctx2[19] },
        dirty[0] & 134217728 && { "aria-controls": ctx2[27] },
        dirty[0] & 134217728 && { "aria-describedby": ctx2[27] },
        dirty[0] & 196608 && get_spread_object(ctx2[16] && ctx2[17] != null ? { placeholder: ctx2[17] } : {}),
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "input$"))
      ]) : {};
      if (!updating_value && dirty[0] & 1) {
        updating_value = true;
        input_1_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_files && dirty[0] & 8) {
        updating_files = true;
        input_1_changes.files = ctx2[3];
        add_flush_callback(() => updating_files = false);
      }
      if (!updating_dirty && dirty[0] & 16) {
        updating_dirty = true;
        input_1_changes.dirty = ctx2[4];
        add_flush_callback(() => updating_dirty = false);
      }
      if (!updating_invalid && dirty[0] & 2) {
        updating_invalid = true;
        input_1_changes.invalid = ctx2[1];
        add_flush_callback(() => updating_invalid = false);
      }
      input_1.$set(input_1_changes);
      if (ctx2[21] != null) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & 2097152) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (suffix_slot) {
        if (suffix_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            suffix_slot,
            suffix_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(suffix_slot_template, ctx2[90], dirty, get_suffix_slot_changes),
            get_suffix_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prefix_slot, local);
      transition_in(if_block0);
      transition_in(input_1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(suffix_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prefix_slot, local);
      transition_out(if_block0);
      transition_out(input_1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(suffix_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (prefix_slot)
        prefix_slot.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t1);
      ctx[63](null);
      destroy_component(input_1, detaching);
      if (detaching)
        detach_dev(t2);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(t3);
      if (suffix_slot)
        suffix_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(124:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let span;
  let textarea_1;
  let updating_value;
  let updating_dirty;
  let updating_invalid;
  let t;
  let span_class_value;
  let current;
  const textarea_1_spread_levels = [
    { disabled: ctx[12] },
    { required: ctx[13] },
    { updateInvalid: ctx[19] },
    { "aria-controls": ctx[27] },
    { "aria-describedby": ctx[27] },
    prefixFilter(ctx[41], "input$")
  ];
  function textarea_1_value_binding(value) {
    ctx[56](value);
  }
  function textarea_1_dirty_binding(value) {
    ctx[57](value);
  }
  function textarea_1_invalid_binding(value) {
    ctx[58](value);
  }
  let textarea_1_props = {};
  for (let i = 0; i < textarea_1_spread_levels.length; i += 1) {
    textarea_1_props = assign(textarea_1_props, textarea_1_spread_levels[i]);
  }
  if (ctx[0] !== void 0) {
    textarea_1_props.value = ctx[0];
  }
  if (ctx[4] !== void 0) {
    textarea_1_props.dirty = ctx[4];
  }
  if (ctx[1] !== void 0) {
    textarea_1_props.invalid = ctx[1];
  }
  textarea_1 = new Textarea_default({ props: textarea_1_props, $$inline: true });
  ctx[55](textarea_1);
  binding_callbacks.push(() => bind(textarea_1, "value", textarea_1_value_binding));
  binding_callbacks.push(() => bind(textarea_1, "dirty", textarea_1_dirty_binding));
  binding_callbacks.push(() => bind(textarea_1, "invalid", textarea_1_invalid_binding));
  textarea_1.$on("blur", ctx[59]);
  textarea_1.$on("focus", ctx[60]);
  textarea_1.$on("blur", ctx[61]);
  textarea_1.$on("focus", ctx[62]);
  const internalCounter_slot_template = ctx[51].internalCounter;
  const internalCounter_slot = create_slot(internalCounter_slot_template, ctx, ctx[90], get_internalCounter_slot_context);
  const block = {
    c: function create() {
      span = element("span");
      create_component(textarea_1.$$.fragment);
      t = space();
      if (internalCounter_slot)
        internalCounter_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      claim_component(textarea_1.$$.fragment, span_nodes);
      t = claim_space(span_nodes);
      if (internalCounter_slot)
        internalCounter_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = classMap({
        "mdc-text-field__resizer": !("input$resizable" in ctx[41]) || ctx[41].input$resizable
      }));
      add_location(span, file6, 99, 6, 3514);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(textarea_1, span, null);
      append_hydration_dev(span, t);
      if (internalCounter_slot) {
        internalCounter_slot.m(span, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      const textarea_1_changes = dirty[0] & 134754304 | dirty[1] & 1024 ? get_spread_update(textarea_1_spread_levels, [
        dirty[0] & 4096 && { disabled: ctx2[12] },
        dirty[0] & 8192 && { required: ctx2[13] },
        dirty[0] & 524288 && { updateInvalid: ctx2[19] },
        dirty[0] & 134217728 && { "aria-controls": ctx2[27] },
        dirty[0] & 134217728 && { "aria-describedby": ctx2[27] },
        dirty[1] & 1024 && get_spread_object(prefixFilter(ctx2[41], "input$"))
      ]) : {};
      if (!updating_value && dirty[0] & 1) {
        updating_value = true;
        textarea_1_changes.value = ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      if (!updating_dirty && dirty[0] & 16) {
        updating_dirty = true;
        textarea_1_changes.dirty = ctx2[4];
        add_flush_callback(() => updating_dirty = false);
      }
      if (!updating_invalid && dirty[0] & 2) {
        updating_invalid = true;
        textarea_1_changes.invalid = ctx2[1];
        add_flush_callback(() => updating_invalid = false);
      }
      textarea_1.$set(textarea_1_changes);
      if (internalCounter_slot) {
        if (internalCounter_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            internalCounter_slot,
            internalCounter_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(internalCounter_slot_template, ctx2[90], dirty, get_internalCounter_slot_changes),
            get_internalCounter_slot_context
          );
        }
      }
      if (!current || dirty[1] & 1024 && span_class_value !== (span_class_value = classMap({
        "mdc-text-field__resizer": !("input$resizable" in ctx2[41]) || ctx2[41].input$resizable
      }))) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(textarea_1.$$.fragment, local);
      transition_in(internalCounter_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(textarea_1.$$.fragment, local);
      transition_out(internalCounter_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span);
      ctx[55](null);
      destroy_component(textarea_1);
      if (internalCounter_slot)
        internalCounter_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(99:4) {#if textarea && typeof value === 'string'}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let prefix_1;
  let current;
  prefix_1 = new Prefix_default({
    props: {
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(prefix_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(prefix_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(prefix_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const prefix_1_changes = {};
      if (dirty[0] & 1048576 | dirty[2] & 268435456) {
        prefix_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      prefix_1.$set(prefix_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(prefix_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(prefix_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(prefix_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(126:6) {#if prefix != null}",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[20]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[20]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1048576)
        set_data_dev(t, ctx2[20]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(127:8) <Prefix>",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let suffix_1;
  let current;
  suffix_1 = new Suffix_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(suffix_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(suffix_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(suffix_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const suffix_1_changes = {};
      if (dirty[0] & 2097152 | dirty[2] & 268435456) {
        suffix_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      suffix_1.$set(suffix_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(suffix_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(suffix_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(suffix_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(148:6) {#if suffix != null}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[21]);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, ctx[21]);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 2097152)
        set_data_dev(t, ctx2[21]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(149:8) <Suffix>",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const trailingIcon_slot_template = ctx[51].trailingIcon;
  const trailingIcon_slot = create_slot(trailingIcon_slot_template, ctx, ctx[90], get_trailingIcon_slot_context);
  const block = {
    c: function create() {
      if (trailingIcon_slot)
        trailingIcon_slot.c();
    },
    l: function claim(nodes) {
      if (trailingIcon_slot)
        trailingIcon_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (trailingIcon_slot) {
        trailingIcon_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (trailingIcon_slot) {
        if (trailingIcon_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            trailingIcon_slot,
            trailingIcon_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(trailingIcon_slot_template, ctx2[90], dirty, get_trailingIcon_slot_changes),
            get_trailingIcon_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(trailingIcon_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(trailingIcon_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (trailingIcon_slot)
        trailingIcon_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(153:4) <ContextFragment key=\\"SMUI:textfield:icon:leading\\" value={false}>',
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let lineripple;
  let current;
  const lineripple_spread_levels = [prefixFilter(ctx[41], "ripple$")];
  let lineripple_props = {};
  for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
    lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
  }
  lineripple = new dist_default3({ props: lineripple_props, $$inline: true });
  ctx[72](lineripple);
  const block = {
    c: function create() {
      create_component(lineripple.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lineripple.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lineripple, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const lineripple_changes = dirty[1] & 1024 ? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(ctx2[41], "ripple$"))]) : {};
      lineripple.$set(lineripple_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineripple.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineripple.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[72](null);
      destroy_component(lineripple, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(156:4) {#if !textarea && variant !== 'outlined' && ripple}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let helperline;
  let current;
  const helperline_spread_levels = [prefixFilter(ctx[41], "helperLine$")];
  let helperline_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < helperline_spread_levels.length; i += 1) {
    helperline_props = assign(helperline_props, helperline_spread_levels[i]);
  }
  helperline = new HelperLine_default({ props: helperline_props, $$inline: true });
  helperline.$on("SMUITextfieldHelperText:id", ctx[85]);
  helperline.$on("SMUITextfieldHelperText:mount", ctx[86]);
  helperline.$on("SMUITextfieldHelperText:unmount", ctx[87]);
  helperline.$on("SMUITextfieldCharacterCounter:mount", ctx[88]);
  helperline.$on("SMUITextfieldCharacterCounter:unmount", ctx[89]);
  const block = {
    c: function create() {
      create_component(helperline.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(helperline.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(helperline, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const helperline_changes = dirty[1] & 1024 ? get_spread_update(helperline_spread_levels, [get_spread_object(prefixFilter(ctx2[41], "helperLine$"))]) : {};
      if (dirty[2] & 268435456) {
        helperline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helperline.$set(helperline_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(helperline.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(helperline.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(helperline, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(217:0) {#if $$slots.helper}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let current;
  const helper_slot_template = ctx[51].helper;
  const helper_slot = create_slot(helper_slot_template, ctx, ctx[90], get_helper_slot_context);
  const block = {
    c: function create() {
      if (helper_slot)
        helper_slot.c();
    },
    l: function claim(nodes) {
      if (helper_slot)
        helper_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (helper_slot) {
        helper_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (helper_slot) {
        if (helper_slot.p && (!current || dirty[2] & 268435456)) {
          update_slot_base(
            helper_slot,
            helper_slot_template,
            ctx2,
            ctx2[90],
            !current ? get_all_dirty_from_scope(ctx2[90]) : get_slot_changes(helper_slot_template, ctx2[90], dirty, get_helper_slot_changes),
            get_helper_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(helper_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(helper_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (helper_slot)
        helper_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(218:2) <HelperLine     on:SMUITextfieldHelperText:id={(event) => (helperId = event.detail)}     on:SMUITextfieldHelperText:mount={(event) => (helperText = event.detail)}     on:SMUITextfieldHelperText:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     on:SMUITextfieldCharacterCounter:mount={(event) =>       (characterCounter = event.detail)}     on:SMUITextfieldCharacterCounter:unmount={() =>       (characterCounter = undefined)}     {...prefixFilter($$restProps, 'helperLine$')}     >",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let current_block_type_index;
  let if_block0;
  let t;
  let if_block1_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[36])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1]);
  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let if_block1 = ctx[42].helper && create_if_block3(ctx);
  const block = {
    c: function create() {
      if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if_block0.l(nodes);
      t = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if_block0.p(ctx2, dirty);
      if (ctx2[42].helper) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[1] & 2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(t);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func4 = ([name, value]) => `${name}: ${value};`;
var func_12 = ([name, value]) => `${name}: ${value};`;
function instance_14($$self, $$props, $$invalidate) {
  let inputElement;
  const omit_props_names = [
    "use",
    "class",
    "style",
    "ripple",
    "disabled",
    "required",
    "textarea",
    "variant",
    "noLabel",
    "label",
    "type",
    "value",
    "files",
    "invalid",
    "updateInvalid",
    "dirty",
    "prefix",
    "suffix",
    "validateOnValueChange",
    "useNativeValidation",
    "withLeadingIcon",
    "withTrailingIcon",
    "input",
    "floatingLabel",
    "lineRipple",
    "notchedOutline",
    "focus",
    "blur",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Textfield", slots, [
    "label",
    "leadingIcon",
    "default",
    "internalCounter",
    "prefix",
    "suffix",
    "trailingIcon",
    "ripple",
    "helper"
  ]);
  const $$slots = compute_slots(slots);
  const { applyPassive } = events_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { disabled = false } = $$props;
  let { required = false } = $$props;
  let { textarea = false } = $$props;
  let { variant = textarea ? "outlined" : "standard" } = $$props;
  let { noLabel = false } = $$props;
  let { label = void 0 } = $$props;
  let { type = "text" } = $$props;
  let { value = $$restProps.input$emptyValueUndefined ? void 0 : uninitializedValue } = $$props;
  let { files = uninitializedValue } = $$props;
  const valued = !isUninitializedValue(value) || !isUninitializedValue(files);
  if (isUninitializedValue(value)) {
    value = void 0;
  }
  if (isUninitializedValue(files)) {
    files = null;
  }
  let { invalid = uninitializedValue } = $$props;
  let { updateInvalid = isUninitializedValue(invalid) } = $$props;
  if (isUninitializedValue(invalid)) {
    invalid = false;
  }
  let { dirty = false } = $$props;
  let { prefix = void 0 } = $$props;
  let { suffix = void 0 } = $$props;
  let { validateOnValueChange = updateInvalid } = $$props;
  let { useNativeValidation = updateInvalid } = $$props;
  let { withLeadingIcon = uninitializedValue } = $$props;
  let { withTrailingIcon = uninitializedValue } = $$props;
  let { input = void 0 } = $$props;
  let { floatingLabel = void 0 } = $$props;
  let { lineRipple = void 0 } = $$props;
  let { notchedOutline = void 0 } = $$props;
  let element2;
  let instance3;
  let internalClasses = {};
  let internalStyles = {};
  let helperId = void 0;
  let focused = false;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let initPromiseResolve;
  let initPromise = new Promise((resolve) => initPromiseResolve = resolve);
  let leadingIcon = void 0;
  let trailingIcon = void 0;
  let helperText = void 0;
  let characterCounter = void 0;
  let previousValue = value;
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onMount(() => {
    $$invalidate(49, instance3 = new MDCTextFieldFoundation(
      {
        addClass,
        removeClass,
        hasClass,
        registerTextFieldInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
        deregisterTextFieldInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler),
        registerValidationAttributeChangeHandler: (handler) => {
          const getAttributesList = (mutationsList) => {
            return mutationsList.map((mutation) => mutation.attributeName).filter((attributeName) => attributeName);
          };
          const observer = new MutationObserver((mutationsList) => {
            if (useNativeValidation) {
              handler(getAttributesList(mutationsList));
            }
          });
          const config = { attributes: true };
          if (input) {
            observer.observe(input.getElement(), config);
          }
          return observer;
        },
        deregisterValidationAttributeChangeHandler: (observer) => {
          observer.disconnect();
        },
        getNativeInput: () => {
          var _a;
          return (_a = input === null || input === void 0 ? void 0 : input.getElement()) !== null && _a !== void 0 ? _a : null;
        },
        setInputAttr: (name, value2) => {
          input === null || input === void 0 ? void 0 : input.addAttr(name, value2);
        },
        removeInputAttr: (name) => {
          input === null || input === void 0 ? void 0 : input.removeAttr(name);
        },
        isFocused: () => document.activeElement === (input === null || input === void 0 ? void 0 : input.getElement()),
        registerInputInteractionHandler: (evtType, handler) => {
          input === null || input === void 0 ? void 0 : input.getElement().addEventListener(evtType, handler, applyPassive());
        },
        deregisterInputInteractionHandler: (evtType, handler) => {
          input === null || input === void 0 ? void 0 : input.getElement().removeEventListener(evtType, handler, applyPassive());
        },
        floatLabel: (shouldFloat) => floatingLabel && floatingLabel.float(shouldFloat),
        getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
        hasLabel: () => !!floatingLabel,
        shakeLabel: (shouldShake) => floatingLabel && floatingLabel.shake(shouldShake),
        setLabelRequired: (isRequired) => floatingLabel && floatingLabel.setRequired(isRequired),
        activateLineRipple: () => lineRipple && lineRipple.activate(),
        deactivateLineRipple: () => lineRipple && lineRipple.deactivate(),
        setLineRippleTransformOrigin: (normalizedX) => lineRipple && lineRipple.setRippleCenter(normalizedX),
        closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
        hasOutline: () => !!notchedOutline,
        notchOutline: (labelWidth) => notchedOutline && notchedOutline.notch(labelWidth)
      },
      {
        get helperText() {
          return helperText;
        },
        get characterCounter() {
          return characterCounter;
        },
        get leadingIcon() {
          return leadingIcon;
        },
        get trailingIcon() {
          return trailingIcon;
        }
      }
    ));
    if (valued) {
      if (input == null) {
        throw new Error("SMUI Textfield initialized without Input component.");
      }
      instance3.init();
    } else {
      tick().then(() => {
        if (input == null) {
          throw new Error("SMUI Textfield initialized without Input component.");
        }
        instance3.init();
      });
    }
    initPromiseResolve();
    return () => {
      instance3.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    var _a;
    return className2 in internalClasses ? (_a = internalClasses[className2]) !== null && _a !== void 0 ? _a : null : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(25, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(25, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value2) {
    if (internalStyles[name] != value2) {
      if (value2 === "" || value2 == null) {
        delete internalStyles[name];
        $$invalidate(26, internalStyles);
      } else {
        $$invalidate(26, internalStyles[name] = value2, internalStyles);
      }
    }
  }
  function focus() {
    input === null || input === void 0 ? void 0 : input.focus();
  }
  function blur() {
    input === null || input === void 0 ? void 0 : input.blur();
  }
  function layout() {
    if (instance3) {
      const openNotch = instance3.shouldFloat;
      instance3.notchOutline(openNotch);
    }
  }
  function getElement() {
    return element2;
  }
  function floatinglabel_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(5, floatingLabel);
    });
  }
  function floatinglabel_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(5, floatingLabel);
    });
  }
  function notchedoutline_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      notchedOutline = $$value;
      $$invalidate(7, notchedOutline);
    });
  }
  function textarea_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  function textarea_1_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function textarea_1_dirty_binding(value2) {
    dirty = value2;
    $$invalidate(4, dirty);
  }
  function textarea_1_invalid_binding(value2) {
    invalid = value2;
    $$invalidate(1, invalid), $$invalidate(49, instance3), $$invalidate(19, updateInvalid);
  }
  const blur_handler = () => $$invalidate(28, focused = false);
  const focus_handler = () => $$invalidate(28, focused = true);
  const blur_handler_1 = (event) => dispatch(element2, "blur", event);
  const focus_handler_1 = (event) => dispatch(element2, "focus", event);
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(2, input);
    });
  }
  function input_1_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  function input_1_files_binding(value2) {
    files = value2;
    $$invalidate(3, files);
  }
  function input_1_dirty_binding(value2) {
    dirty = value2;
    $$invalidate(4, dirty);
  }
  function input_1_invalid_binding(value2) {
    invalid = value2;
    $$invalidate(1, invalid), $$invalidate(49, instance3), $$invalidate(19, updateInvalid);
  }
  const blur_handler_2 = () => $$invalidate(28, focused = false);
  const focus_handler_2 = () => $$invalidate(28, focused = true);
  const blur_handler_3 = (event) => dispatch(element2, "blur", event);
  const focus_handler_3 = (event) => dispatch(element2, "focus", event);
  function lineripple_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      lineRipple = $$value;
      $$invalidate(6, lineRipple);
    });
  }
  function label_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(24, element2);
    });
  }
  const SMUITextfieldLeadingIcon_mount_handler = (event) => $$invalidate(29, leadingIcon = event.detail);
  const SMUITextfieldLeadingIcon_unmount_handler = () => $$invalidate(29, leadingIcon = void 0);
  const SMUITextfieldTrailingIcon_mount_handler = (event) => $$invalidate(30, trailingIcon = event.detail);
  const SMUITextfieldTrailingIcon_unmount_handler = () => $$invalidate(30, trailingIcon = void 0);
  const SMUITextfieldCharacterCounter_mount_handler = (event) => $$invalidate(32, characterCounter = event.detail);
  const SMUITextfieldCharacterCounter_unmount_handler = () => $$invalidate(32, characterCounter = void 0);
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(24, element2);
    });
  }
  const SMUITextfieldLeadingIcon_mount_handler_1 = (event) => $$invalidate(29, leadingIcon = event.detail);
  const SMUITextfieldLeadingIcon_unmount_handler_1 = () => $$invalidate(29, leadingIcon = void 0);
  const SMUITextfieldTrailingIcon_mount_handler_1 = (event) => $$invalidate(30, trailingIcon = event.detail);
  const SMUITextfieldTrailingIcon_unmount_handler_1 = () => $$invalidate(30, trailingIcon = void 0);
  const SMUITextfieldHelperText_id_handler = (event) => $$invalidate(27, helperId = event.detail);
  const SMUITextfieldHelperText_mount_handler = (event) => $$invalidate(31, helperText = event.detail);
  const SMUITextfieldHelperText_unmount_handler = () => {
    $$invalidate(27, helperId = void 0);
    $$invalidate(31, helperText = void 0);
  };
  const SMUITextfieldCharacterCounter_mount_handler_1 = (event) => $$invalidate(32, characterCounter = event.detail);
  const SMUITextfieldCharacterCounter_unmount_handler_1 = () => $$invalidate(32, characterCounter = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(41, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(8, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(9, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(10, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(11, ripple = $$new_props.ripple);
    if ("disabled" in $$new_props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("required" in $$new_props)
      $$invalidate(13, required = $$new_props.required);
    if ("textarea" in $$new_props)
      $$invalidate(14, textarea = $$new_props.textarea);
    if ("variant" in $$new_props)
      $$invalidate(15, variant = $$new_props.variant);
    if ("noLabel" in $$new_props)
      $$invalidate(16, noLabel = $$new_props.noLabel);
    if ("label" in $$new_props)
      $$invalidate(17, label = $$new_props.label);
    if ("type" in $$new_props)
      $$invalidate(18, type = $$new_props.type);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("files" in $$new_props)
      $$invalidate(3, files = $$new_props.files);
    if ("invalid" in $$new_props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(19, updateInvalid = $$new_props.updateInvalid);
    if ("dirty" in $$new_props)
      $$invalidate(4, dirty = $$new_props.dirty);
    if ("prefix" in $$new_props)
      $$invalidate(20, prefix = $$new_props.prefix);
    if ("suffix" in $$new_props)
      $$invalidate(21, suffix = $$new_props.suffix);
    if ("validateOnValueChange" in $$new_props)
      $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
    if ("useNativeValidation" in $$new_props)
      $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
    if ("withLeadingIcon" in $$new_props)
      $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
    if ("withTrailingIcon" in $$new_props)
      $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
    if ("input" in $$new_props)
      $$invalidate(2, input = $$new_props.input);
    if ("floatingLabel" in $$new_props)
      $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
    if ("lineRipple" in $$new_props)
      $$invalidate(6, lineRipple = $$new_props.lineRipple);
    if ("notchedOutline" in $$new_props)
      $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
    if ("$$scope" in $$new_props)
      $$invalidate(90, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCTextFieldFoundation,
    events: events_exports,
    onMount,
    onDestroy,
    getContext,
    tick,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    ContextFragment: ContextFragment_default,
    Ripple: dist_default,
    FloatingLabel: dist_default2,
    LineRipple: dist_default3,
    NotchedOutline: dist_default4,
    HelperLine: HelperLine_default,
    Prefix: Prefix_default,
    Suffix: Suffix_default,
    Input: Input_default,
    Textarea: Textarea_default,
    applyPassive,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    style,
    ripple,
    disabled,
    required,
    textarea,
    variant,
    noLabel,
    label,
    type,
    value,
    files,
    valued,
    invalid,
    updateInvalid,
    dirty,
    prefix,
    suffix,
    validateOnValueChange,
    useNativeValidation,
    withLeadingIcon,
    withTrailingIcon,
    input,
    floatingLabel,
    lineRipple,
    notchedOutline,
    element: element2,
    instance: instance3,
    internalClasses,
    internalStyles,
    helperId,
    focused,
    addLayoutListener,
    removeLayoutListener,
    initPromiseResolve,
    initPromise,
    leadingIcon,
    trailingIcon,
    helperText,
    characterCounter,
    previousValue,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    focus,
    blur,
    layout,
    getElement,
    inputElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(8, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(9, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(10, style = $$new_props.style);
    if ("ripple" in $$props)
      $$invalidate(11, ripple = $$new_props.ripple);
    if ("disabled" in $$props)
      $$invalidate(12, disabled = $$new_props.disabled);
    if ("required" in $$props)
      $$invalidate(13, required = $$new_props.required);
    if ("textarea" in $$props)
      $$invalidate(14, textarea = $$new_props.textarea);
    if ("variant" in $$props)
      $$invalidate(15, variant = $$new_props.variant);
    if ("noLabel" in $$props)
      $$invalidate(16, noLabel = $$new_props.noLabel);
    if ("label" in $$props)
      $$invalidate(17, label = $$new_props.label);
    if ("type" in $$props)
      $$invalidate(18, type = $$new_props.type);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("files" in $$props)
      $$invalidate(3, files = $$new_props.files);
    if ("invalid" in $$props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$props)
      $$invalidate(19, updateInvalid = $$new_props.updateInvalid);
    if ("dirty" in $$props)
      $$invalidate(4, dirty = $$new_props.dirty);
    if ("prefix" in $$props)
      $$invalidate(20, prefix = $$new_props.prefix);
    if ("suffix" in $$props)
      $$invalidate(21, suffix = $$new_props.suffix);
    if ("validateOnValueChange" in $$props)
      $$invalidate(43, validateOnValueChange = $$new_props.validateOnValueChange);
    if ("useNativeValidation" in $$props)
      $$invalidate(44, useNativeValidation = $$new_props.useNativeValidation);
    if ("withLeadingIcon" in $$props)
      $$invalidate(22, withLeadingIcon = $$new_props.withLeadingIcon);
    if ("withTrailingIcon" in $$props)
      $$invalidate(23, withTrailingIcon = $$new_props.withTrailingIcon);
    if ("input" in $$props)
      $$invalidate(2, input = $$new_props.input);
    if ("floatingLabel" in $$props)
      $$invalidate(5, floatingLabel = $$new_props.floatingLabel);
    if ("lineRipple" in $$props)
      $$invalidate(6, lineRipple = $$new_props.lineRipple);
    if ("notchedOutline" in $$props)
      $$invalidate(7, notchedOutline = $$new_props.notchedOutline);
    if ("element" in $$props)
      $$invalidate(24, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(49, instance3 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(25, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(26, internalStyles = $$new_props.internalStyles);
    if ("helperId" in $$props)
      $$invalidate(27, helperId = $$new_props.helperId);
    if ("focused" in $$props)
      $$invalidate(28, focused = $$new_props.focused);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("initPromiseResolve" in $$props)
      initPromiseResolve = $$new_props.initPromiseResolve;
    if ("initPromise" in $$props)
      $$invalidate(37, initPromise = $$new_props.initPromise);
    if ("leadingIcon" in $$props)
      $$invalidate(29, leadingIcon = $$new_props.leadingIcon);
    if ("trailingIcon" in $$props)
      $$invalidate(30, trailingIcon = $$new_props.trailingIcon);
    if ("helperText" in $$props)
      $$invalidate(31, helperText = $$new_props.helperText);
    if ("characterCounter" in $$props)
      $$invalidate(32, characterCounter = $$new_props.characterCounter);
    if ("previousValue" in $$props)
      $$invalidate(50, previousValue = $$new_props.previousValue);
    if ("inputElement" in $$props)
      $$invalidate(33, inputElement = $$new_props.inputElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 4) {
      $:
        $$invalidate(33, inputElement = input && input.getElement());
    }
    if ($$self.$$.dirty[0] & 524290 | $$self.$$.dirty[1] & 262144) {
      $:
        if (instance3 && instance3.isValid() !== !invalid) {
          if (updateInvalid) {
            $$invalidate(1, invalid = !instance3.isValid());
          } else {
            instance3.setValid(!invalid);
          }
        }
    }
    if ($$self.$$.dirty[1] & 266240) {
      $:
        if (instance3 && instance3.getValidateOnValueChange() !== validateOnValueChange) {
          instance3.setValidateOnValueChange(isUninitializedValue(validateOnValueChange) ? false : validateOnValueChange);
        }
    }
    if ($$self.$$.dirty[1] & 270336) {
      $:
        if (instance3) {
          instance3.setUseNativeValidation(isUninitializedValue(useNativeValidation) ? true : useNativeValidation);
        }
    }
    if ($$self.$$.dirty[0] & 4096 | $$self.$$.dirty[1] & 262144) {
      $:
        if (instance3) {
          instance3.setDisabled(disabled);
        }
    }
    if ($$self.$$.dirty[0] & 1 | $$self.$$.dirty[1] & 786432) {
      $:
        if (instance3 && valued && previousValue !== value) {
          $$invalidate(50, previousValue = value);
          const stringValue = `${value}`;
          if (instance3.getValue() !== stringValue) {
            instance3.setValue(stringValue);
          }
        }
    }
  };
  return [
    value,
    invalid,
    input,
    files,
    dirty,
    floatingLabel,
    lineRipple,
    notchedOutline,
    use,
    className,
    style,
    ripple,
    disabled,
    required,
    textarea,
    variant,
    noLabel,
    label,
    type,
    updateInvalid,
    prefix,
    suffix,
    withLeadingIcon,
    withTrailingIcon,
    element2,
    internalClasses,
    internalStyles,
    helperId,
    focused,
    leadingIcon,
    trailingIcon,
    helperText,
    characterCounter,
    inputElement,
    forwardEvents,
    isUninitializedValue,
    valued,
    initPromise,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    $$slots,
    validateOnValueChange,
    useNativeValidation,
    focus,
    blur,
    layout,
    getElement,
    instance3,
    previousValue,
    slots,
    floatinglabel_binding,
    floatinglabel_binding_1,
    notchedoutline_binding,
    textarea_1_binding,
    textarea_1_value_binding,
    textarea_1_dirty_binding,
    textarea_1_invalid_binding,
    blur_handler,
    focus_handler,
    blur_handler_1,
    focus_handler_1,
    input_1_binding,
    input_1_value_binding,
    input_1_files_binding,
    input_1_dirty_binding,
    input_1_invalid_binding,
    blur_handler_2,
    focus_handler_2,
    blur_handler_3,
    focus_handler_3,
    lineripple_binding,
    label_1_binding,
    SMUITextfieldLeadingIcon_mount_handler,
    SMUITextfieldLeadingIcon_unmount_handler,
    SMUITextfieldTrailingIcon_mount_handler,
    SMUITextfieldTrailingIcon_unmount_handler,
    SMUITextfieldCharacterCounter_mount_handler,
    SMUITextfieldCharacterCounter_unmount_handler,
    div_binding,
    SMUITextfieldLeadingIcon_mount_handler_1,
    SMUITextfieldLeadingIcon_unmount_handler_1,
    SMUITextfieldTrailingIcon_mount_handler_1,
    SMUITextfieldTrailingIcon_unmount_handler_1,
    SMUITextfieldHelperText_id_handler,
    SMUITextfieldHelperText_mount_handler,
    SMUITextfieldHelperText_unmount_handler,
    SMUITextfieldCharacterCounter_mount_handler_1,
    SMUITextfieldCharacterCounter_unmount_handler_1,
    $$scope
  ];
}
var Textfield = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_14,
      create_fragment6,
      safe_not_equal,
      {
        use: 8,
        class: 9,
        style: 10,
        ripple: 11,
        disabled: 12,
        required: 13,
        textarea: 14,
        variant: 15,
        noLabel: 16,
        label: 17,
        type: 18,
        value: 0,
        files: 3,
        invalid: 1,
        updateInvalid: 19,
        dirty: 4,
        prefix: 20,
        suffix: 21,
        validateOnValueChange: 43,
        useNativeValidation: 44,
        withLeadingIcon: 22,
        withTrailingIcon: 23,
        input: 2,
        floatingLabel: 5,
        lineRipple: 6,
        notchedOutline: 7,
        focus: 45,
        blur: 46,
        layout: 47,
        getElement: 48
      },
      null,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Textfield",
      options,
      id: create_fragment6.name
    });
  }
  get use() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textarea() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textarea(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get files() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set files(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateInvalid() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateInvalid(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dirty() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dirty(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get prefix() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set prefix(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get suffix() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set suffix(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validateOnValueChange() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validateOnValueChange(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useNativeValidation() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useNativeValidation(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withLeadingIcon() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withLeadingIcon(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withTrailingIcon() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withTrailingIcon(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatingLabel() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatingLabel(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get lineRipple() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set lineRipple(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notchedOutline() {
    throw new Error_1("<Textfield>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notchedOutline(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[45];
  }
  set focus(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get blur() {
    return this.$$.ctx[46];
  }
  set blur(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[47];
  }
  set layout(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[48];
  }
  set getElement(value) {
    throw new Error_1("<Textfield>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Textfield_default = Textfield;

// node_modules/@smui/textfield/dist/index.js
var dist_default5 = Textfield_default;
export {
  HelperLine_default as HelperLine,
  Input_default as Input,
  Prefix_default as Prefix,
  Suffix_default as Suffix,
  Textarea_default as Textarea,
  dist_default5 as default
};
//# sourceMappingURL=@smui_textfield.js.map
